<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>picgo图床设置与typora配置</title>
      <link href="/2023/01/11/picgo-tu-chuang-she-zhi-yu-typora-pei-zhi/"/>
      <url>/2023/01/11/picgo-tu-chuang-she-zhi-yu-typora-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    PicGo是一个热门的图床工具，是可以自动把本地图片转换成链接的一款工具，是一款简洁容易操作的图床工具，可以支持微博、腾讯云、Github、阿里云等常用图床，功能可以说非常强大。</p><p>​    Typora是一款跨平台的Markdown编辑器软件，我们常常用它来写笔记或者博客。当使用Typora做笔记时，常常需要上传知识点截图到笔记上。截图图像为本地图像（存储在自己的电脑上，当我们把电脑本地图像进行删除或者误删时，再次打开笔记之前的截图都会显示丢，或者作为博客时，需要部署到远程仓库或服务器，而本地图片显然不能满足我们的需求。</p><p>​    使用PicGo图床工具将截图图像转换成链接或者上传到远程仓库服务器，当下次打开笔记或者查看远程博客时，编辑器会通过链接返回图像，上传后删除本地图像图像也不会丢失。下面将以配置picgo来介绍图床的搭建和配置使用以及介绍typora的图床配置。</p><p>​    </p><h2 id="PicGo下载"><a href="#PicGo下载" class="headerlink" title="PicGo下载"></a>PicGo下载</h2><p>Picgo最新图床工具下载链接：</p><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>mac系统选择dmg下载，windows选择.exe下载。</p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111200044898.png" alt="图床下载地址"></p><p><strong>此处建议下载稳定的正式版本。</strong></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111200208026.png" alt="下载最新稳定版本"></p><p><strong>翻到下面进行下载安装。</strong></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111200504555.png" alt="下载对应系统版本"></p><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><p>​    下面将介绍和使用==GitHub==来作为==图床==的具体用法。由于在国内有时无法访问GitHub或者速度过慢，这里Reason推荐先搭个梯子。</p><h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><hr><ol><li><p>首先登陆 GitHub，点击右上角的==+==，点击新建一个**仓库（New repository)**。</p><p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111201103490.png" alt="新建仓库"></p></li><li><p>进入页面，设置仓库名称， 选择仓库类型为==公开（Public）==， 由于私有仓库只有自己能够访问，上传图像后无法显示，所以必须时公有仓库。</p><p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111201536456.png" alt="设置远程仓库"></p></li><li><p>创建远程仓库后，点击右上角头像，进入设置。</p><p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111201701845.png" alt="进入设置"></p></li><li><p>接下来需要在 github 上生成一个token以便于 PicGo 根据令牌信息上传图像到我们的仓库。进入设置后，划到最下面左边栏中选择==开发人员设置（Developer settings）==进入页面就可以看到 Personal access tokens。</p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111202147175.png" alt="开发者设置选项" style="zoom:50%;" /></li><li><p>点击==Generate new token== 创建一个新token，这里我选择classic模式。</p><p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111202739291.png" alt="Generate选项"></p></li><li><p>生成令牌，过程如图，选择完后划到最下面按下==Generate token==，即可生成令牌。</p><p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111203414659.png" alt="生成令牌过程"></p></li><li><p>生成token如图所示，请注意蓝色框提醒==务必立即复制您的个人访问令牌。你将无法再看到它==，请先将生成的token复制保存下来，退出此页面后将<strong>再也看不到该token</strong>。</p></li></ol><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111203754137.png" alt="复制令牌"></p><h3 id="PicGo配置与使用"><a href="#PicGo配置与使用" class="headerlink" title="PicGo配置与使用"></a>PicGo配置与使用</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><hr><p>​    打开 PicGo，进入github设置</p><ul><li><p>仓库名格式： <code>用户名/仓库名</code>，例如<code>reasonllh/picgoIMG</code></p></li><li><p>分支名：main</p></li><li><p>token令牌：刚刚从复制保存的token令牌粘贴到此处</p></li><li><p>可以将此设置为默认图床</p></li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111204300355.png" alt="picGo图床设置"></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>​    picgo的图片上传方式就很多了，可以将图片拖拽到此处，也可以上传图片上传，更多的用法可以参考官方文档：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>![picgo图片上传区](/Users/mac/Library/Application Support/typora-user-images/image-20230111204629183.png)</p><hr><h2 id="Typora图床设置"><a href="#Typora图床设置" class="headerlink" title="Typora图床设置"></a>Typora图床设置</h2><p>​    相信很多小伙伴也跟Reason一样有写博客的需求，而typora是一款很多程序员使用的编写markdown格式的软件，下面将介绍typora的图床有关配置。</p><ol><li>打开<code>Typora</code>，点击左上角菜单栏进入==偏好设置==。</li><li>选择 <code>图像</code> ，在<code>上传服务</code>一栏中选择<code>PicGo</code>。注意如果是windows的话还需要选择PicGo.exe的路径，最后点击<code>验证图片上传选项</code>显示成功即Typora配置图床工具完成。</li></ol><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111205309304.png" alt="typora设置"></p><ol start="3"><li><p>将图片放入Typora笔记中，右击图像选择==上传图片==即可上传到远程仓库。</p><p> <img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111205714617.png" alt="上传图片选项"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux复习</title>
      <link href="/2023/01/11/linux-fu-xi/"/>
      <url>/2023/01/11/linux-fu-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-复习"><a href="#Linux-复习" class="headerlink" title="Linux 复习"></a>Linux 复习</h1><h2 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h2><h3 id="Linux-的起源、历史、特点、定义"><a href="#Linux-的起源、历史、特点、定义" class="headerlink" title="Linux 的起源、历史、特点、定义"></a>Linux 的起源、历史、特点、定义</h3><ul><li>Linux 是一个类 Unix 内核的可以自由发布的实现版本，是一个<strong>操作系统的底层核心（内核）</strong></li><li>Linux =&gt; 内核</li><li>Linux 系统 =&gt; 内核 + 工具 + 配套软件</li><li>特点：</li></ul><blockquote><ul><li>开放性（遵循标准）</li><li>多用户</li><li>多任务</li><li>良好的用户界面</li><li>设备独立性（把外部设备当做文件处理）</li><li>丰富的网络功能</li><li>可靠的系统安全</li><li>良好的可移植性</li></ul></blockquote><h3 id="GNU、GPL"><a href="#GNU、GPL" class="headerlink" title="GNU、GPL"></a>GNU、GPL</h3><ol><li>GNU = GNU‘s Not Unix</li><li>GNU 计划：1983 年 Richard Stallman 创办 GNU 计划，旨在建立一套完全自由和可移植的类 Unix 操作系统</li><li>GNU GPL：GNU General Public License(GNU 通用公共许可证)</li><li>GPL 核心思想：<br>保证任何人有共享、修改、发布自由软件的自由<br>自由软件的衍生产品必须以 GPL 为重新发布的许可证<br>允许公司销售自由软件（硬件/服务），提供源代码</li></ol><h3 id="常见发行版本"><a href="#常见发行版本" class="headerlink" title="常见发行版本"></a>常见发行版本</h3><h3 id="商业、共享、自由和免费软件的区别和联系"><a href="#商业、共享、自由和免费软件的区别和联系" class="headerlink" title="商业、共享、自由和免费软件的区别和联系"></a>商业、共享、自由和免费软件的区别和联系</h3><h4 id="商业软件"><a href="#商业软件" class="headerlink" title="商业软件"></a>商业软件</h4><ul><li>Commercial Software</li><li>由开发者出售拷贝并提供技术服务</li><li><strong>用户只有使用权</strong></li><li><strong>不提供源代码</strong></li></ul><h4 id="共享（试用软件）"><a href="#共享（试用软件）" class="headerlink" title="共享（试用软件）"></a>共享（试用软件）</h4><ul><li>Shareware</li><li>开发者提供软件试用程序拷贝授权、升级和技术服务</li><li><strong>用户在试用该程序拷贝一段时间之后，必须向开发者交纳使用费用，否则不能继续使用</strong></li><li><strong>不提供源代码</strong></li></ul><h4 id="自由软件"><a href="#自由软件" class="headerlink" title="自由软件"></a>自由软件</h4><ul><li>Freeware 或 Free Software</li><li><strong>源代码必须公开</strong></li><li><strong>任何人都可以自由传播、下载、使用、改写、重新发布</strong></li><li><strong>自由软件不一定免费</strong></li></ul><h4 id="免费软件"><a href="#免费软件" class="headerlink" title="免费软件"></a>免费软件</h4><ul><li>Freeware</li><li><strong>不需付钱，但免费软件不一定提供源代码</strong></li><li><strong>只有当自由软件免费或者免费软件提供源代码的时候才是一样的</strong></li></ul><h2 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h2><h3 id="Linux-的安装方式（区别和联系，如何选择）、安装过程、远程连接方式"><a href="#Linux-的安装方式（区别和联系，如何选择）、安装过程、远程连接方式" class="headerlink" title="Linux 的安装方式（区别和联系，如何选择）、安装过程、远程连接方式"></a>Linux 的安装方式（区别和联系，如何选择）、安装过程、远程连接方式</h3><h3 id="Linux-内核版本号"><a href="#Linux-内核版本号" class="headerlink" title="Linux 内核版本号"></a>Linux 内核版本号</h3><h4 id="内核版本号"><a href="#内核版本号" class="headerlink" title="内核版本号"></a>内核版本号</h4><ul><li><strong>由 Linus 等人制定和维护，全球统一</strong></li><li>内核版本号格式：x. y. zz</li><li>x 为主版本号</li><li>y 为次版本号</li><li>zz 为次次版本号</li></ul><h5 id="稳定版"><a href="#稳定版" class="headerlink" title="稳定版"></a>稳定版</h5><ul><li>​ 内核的特性已经固定，代码运行稳定可靠，不再增加新的特性，要改进也只是修改代码中的错误。</li></ul><h5 id="2-6-及以下版本（x-y-zz）"><a href="#2-6-及以下版本（x-y-zz）" class="headerlink" title="2.6 及以下版本（x.y.zz）"></a>2.6 及以下版本（x.<strong>y</strong>.zz）</h5><ul><li><strong>次版本号=偶数 =&gt; 稳定版本</strong></li><li><strong>次版本号=奇数 =&gt; 测试版本</strong></li></ul><h5 id="3-0-开始"><a href="#3-0-开始" class="headerlink" title="3.0 开始"></a>3.0 开始</h5><ul><li><strong>次版本号</strong>不再表示一个内核是稳定版本还是测试版本，所有发布出来的正式版本都是稳定版本</li></ul><h4 id="发行版本号"><a href="#发行版本号" class="headerlink" title="发行版本号"></a>发行版本号</h4><ul><li>由各个发行公司或者组织自行制定</li><li>不同公司的发行版本之间无可比性</li></ul><h3 id="Linux-目录结构、常见目录的作用和存放内容"><a href="#Linux-目录结构、常见目录的作用和存放内容" class="headerlink" title="Linux 目录结构、常见目录的作用和存放内容"></a>Linux 目录结构、常见目录的作用和存放内容</h3><ul><li><strong>/bin：常见系统程序目录</strong></li><li>/boot：开机设定目录，也是摆放核心 vmlinuz 的地方</li><li>/dev： 摆放系统设备装置文件的目录</li><li>/etc：系统配置文件，尤其 passwd，shadow</li><li>/etc/rc.d/init.d：摆放系统开机的時候载入服务的脚本</li><li><strong>/home：系统使用者的目录</strong></li><li>/lib：Linux 执行或编译程序函数库目录</li><li><strong>/mnt：软驱与光驱接入挂载的地方</strong></li><li>/proc：系统核心与执行程序的一些信息</li><li><strong>/root：系统管理员的目录</strong></li><li><strong>/usr/bin，/bin：一般执行文件摆放的地方</strong></li><li><strong>/usr/sbin，/sbin：系统管理员常用指令集</strong></li><li>/var：摆放系统日志文件的地方</li><li>/lost+fount：摆放系统不正常产生错误时遗失的片段</li></ul><h3 id="Linux-系统结构图、主要组件构成"><a href="#Linux-系统结构图、主要组件构成" class="headerlink" title="Linux 系统结构图、主要组件构成"></a>Linux 系统结构图、主要组件构成</h3><h4 id="系统结构图"><a href="#系统结构图" class="headerlink" title="系统结构图"></a>系统结构图</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523100917154.png" alt="image-20230523100917154"></p><h4 id="主要组件构成"><a href="#主要组件构成" class="headerlink" title="主要组件构成"></a>主要组件构成</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523101023169.png" alt="image-20230523101023169"></p><h3 id="关机、重启命令"><a href="#关机、重启命令" class="headerlink" title="关机、重启命令"></a>关机、重启命令</h3><p><strong>不允许普通用户关机和重启</strong></p><h4 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h4><ul><li>shutdown -h now</li><li>init 0</li><li>halt -p</li><li>poweroff -p</li></ul><h4 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h4><ul><li>shutdown -r now</li><li>init 6</li><li>reboot</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523102233716.png" alt="image-20230523102233716"></p><ul><li>例子</li><li>立即关机# shutdown -h now</li><li>指定 10 分钟后关机# shutdown -h 10</li><li>在关机动作触发前取消关机动作# shutdown -c</li><li>重新启动计算机# shutdown -r now</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523102338170.png" alt="image-20230523102338170"></p><ul><li>例子</li><li>切换到图形化界面# init 5</li><li>切换到多用户的字符界面# init 3</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523102421758.png" alt="image-20230523102421758"></p><ul><li>例子</li><li>关闭系统后关闭电源# halt -p</li><li>关闭系统，但不留下日记记录# halt -d</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523102504768.png" alt="image-20230523102504768"></p><h3 id="说明文档查看"><a href="#说明文档查看" class="headerlink" title="说明文档查看"></a>说明文档查看</h3><p>man | info</p><p>man xxx | info xxx</p><ul><li>回车 下一行</li><li>空格 下一页</li><li>q 退出</li></ul><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523102649602.png" alt="image-20230523102649602" style="zoom:50%;" /><h2 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h2><h3 id="Linux-交互方式"><a href="#Linux-交互方式" class="headerlink" title="Linux 交互方式"></a>Linux 交互方式</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523103851661.png" alt="image-20230523103851661"></p><h3 id="shell-的作用、种类、默认-shell"><a href="#shell-的作用、种类、默认-shell" class="headerlink" title="shell 的作用、种类、默认 shell"></a>shell 的作用、种类、默认 shell</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>​ Shell 是一个作为<strong>用户与 Linux 系统间接口的程序</strong>，它允许用户向操作系统输入需要执行的命令，返回执行结果</li><li>在 Linux 中可存在多种 Shell，<strong>一个用户同一时刻只能使用一个 shell</strong></li><li>实现自动化运维</li></ul><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul><li>ash<br>贝尔实验室开发的 shell，bsh 是对<strong>ash</strong>的<strong>符号链接</strong></li><li>bash<br>GNU 的 Bourne Again Shell，是 GNU Linux 操作系统上<strong>默认的 Shell</strong>。sh 以及 bash2 都是对它的符号链接</li><li>tcsh</li><li>ksh</li><li>zsh</li></ul><h4 id="默认-shell"><a href="#默认-shell" class="headerlink" title="默认 shell"></a>默认 shell</h4><ul><li>GNU Linux 工具中使用的是 bash shell</li><li><strong>作为/bin/sh 被默认安装</strong></li><li>大多数 Linux 发行版中，shell 程序/bin/sh 实际上是对程序/bin/bash 的一个链接</li><li>如何知道/bin/sh 链接到/bin/bash？<br>ls -l /bin/sh</li></ul><h3 id="shell-的功能（命令行提示符、自动补齐、历史记录查看、常用的快捷键、重定向、管道）"><a href="#shell-的功能（命令行提示符、自动补齐、历史记录查看、常用的快捷键、重定向、管道）" class="headerlink" title="shell 的功能（命令行提示符、自动补齐、历史记录查看、常用的快捷键、重定向、管道）"></a>shell 的功能（命令行提示符、自动补齐、历史记录查看、常用的快捷键、重定向、管道）</h3><ul><li><p>#</p><p>root(超级管理员)的命令提示符</p></li><li><p>$<br>非 root 用户的命令提示符</p></li><li><p>命令自动补齐</p><ul><li>输入命令/文件/目录的部分字符，按 tab 键</li><li>列出符合前缀的匹配项列表如果唯一，则自动补齐</li><li>按一下没反应，按两下</li></ul></li><li><p>历史记录查看</p><ul><li><p>键盘 ↑↓ 键 上下翻看历史输入命令</p></li><li><p>ctrl + p 前一条指令</p></li><li><p>ctrl + n 后一条指令</p></li><li><p>ctrl + r 反向搜索命令历史记录</p><blockquote><p>输入内容后，系统会找到最近一个包含这个内容的命令</p><p>找到命令后，按回车执行命令，按上下键查找该命令前后命令，按左右键移动光标并修改命令</p></blockquote></li></ul></li><li><p>光标移动</p><ul><li>ctrl + a 移动光标到行首</li><li>ctrl + e 移动光标到行尾</li><li>ctrl + d 删除光标所在字符</li><li>ctrl + u 剪切到行首</li><li>ctrl + k 剪切到行尾</li></ul></li><li><p>输入输出重定向(&gt;, &gt;&gt;, &lt;)</p><ul><li><p>&lt; 文件</p><p>输入重定向</p><p>wc -l &lt; list.txt</p></li><li><p>&gt;文件</p><p>输出重定向 <em>覆盖原有内容</em></p><p>ls &gt; list.txt</p></li><li><p>&gt;&gt;文件</p><p>追加重定向 <em>文件末尾添加</em></p><p>echo abc &gt;&gt; list.txt</p></li></ul></li><li><p>管道(|)</p><ul><li>把前一个命令的输出作为下一个命令的输入</li><li>格式：命令 1 | 命令 2 | 命令 3 …</li><li>例子：# cat /etc/passwd | grep root | wc -l</li></ul></li></ul><h3 id="clear、echo、ls、cd、pwd、mkdir、rmdir、rm、touch、cat、more、less、head、tail、cp、mv"><a href="#clear、echo、ls、cd、pwd、mkdir、rmdir、rm、touch、cat、more、less、head、tail、cp、mv" class="headerlink" title="clear、echo、ls、cd、pwd、mkdir、rmdir、rm、touch、cat、more、less、head、tail、cp、mv"></a>clear、echo、ls、cd、pwd、mkdir、rmdir、rm、touch、cat、more、less、head、tail、cp、mv</h3><h4 id="命令-clear"><a href="#命令-clear" class="headerlink" title="命令 clear"></a>命令 clear</h4><p>作用：清空屏幕</p><p>格式： clear</p><h4 id="命令-echo"><a href="#命令-echo" class="headerlink" title="命令 echo"></a>命令 echo</h4><p>作用：打印内容</p><p>格式：echo [-n] 字符串</p><p>例子</p><ul><li><p># echo hello world</p></li><li><p># echo -n input something</p></li></ul><h4 id="命令-ls"><a href="#命令-ls" class="headerlink" title="命令: ls"></a>命令: ls</h4><p>作用：显示指定工作目录下的内容</p><p>格式：ls [选项] &lt;路径&gt; …</p><table><thead><tr><th>-a</th><th>all, 列出所有文件，包含隐藏文件</th></tr></thead><tbody><tr><td>-l</td><td>long, 长格式打印</td></tr><tr><td>-i</td><td>inode, 列出 inode 节点的值</td></tr><tr><td>-t</td><td>time, 按时间排序</td></tr><tr><td>-S</td><td>size, 按文件大小排序</td></tr><tr><td>-d</td><td>directory, 只显示目录，不显示目录下的内容</td></tr><tr><td>-R</td><td>recursive, 递归显示目录及子目录的内容</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523120450776.png" alt="image-20230523120450776"></p><p>例子</p><ul><li># ls -ail</li><li># ls -lR /etc</li><li># ls -lS /var/log</li></ul><h4 id="命令-cd"><a href="#命令-cd" class="headerlink" title="命令 cd"></a>命令 cd</h4><p>作用：切换目录</p><p>格式： cd 路径</p><p>例子</p><ul><li># cd dir1</li><li># cd /</li></ul><h4 id="命令-pwd"><a href="#命令-pwd" class="headerlink" title="命令 pwd"></a>命令 pwd</h4><p>作用：显示当前路径</p><p>格式： pwd</p><p>例子# pwd</p><h4 id="命令-mkdir"><a href="#命令-mkdir" class="headerlink" title="命令 mkdir"></a>命令 mkdir</h4><p>作用：创建目录</p><p>格式：mkdir [选项] &lt;目录&gt;…</p><p>​ -p 自动创建不存在的中间目录</p><p>例子</p><ul><li># mkdir dir1 dir2</li><li># mkdir dir1/dir3</li><li># mkdir dir4/dir5</li><li># mkdir -p dir4/dir5</li></ul><h4 id="命令-rmdir"><a href="#命令-rmdir" class="headerlink" title="命令 rmdir"></a>命令 rmdir</h4><p>作用：删除目录。只能删除空目录</p><p>格式：rmdir [选项] &lt;目录&gt;…</p><p>​ -p 删除路径中的空目录</p><p>例子</p><ul><li># rmdir dir1</li><li># rmdir -p dir3</li></ul><h4 id="命令-rm"><a href="#命令-rm" class="headerlink" title="命令 rm"></a>命令 rm</h4><p>作用：删除文件或目录</p><p>格式： rm [选项] &lt;路径&gt;…</p><table><thead><tr><th>-r</th><th>递归删除子目录的内容</th></tr></thead><tbody><tr><td>-f</td><td>强制不提示</td></tr></tbody></table><p>例子</p><ul><li># rm file</li><li># rm -f file</li><li># rm -r dir1</li><li># rm -rf dir1</li></ul><h4 id="命令-touch"><a href="#命令-touch" class="headerlink" title="命令 touch"></a>命令 touch</h4><p>作用：用于改变文件的时间记录或创建一个空文件</p><p>格式：touch [选项] &lt;文件&gt; …</p><table><thead><tr><th>-a</th><th>改变档案的读取时间记录</th></tr></thead><tbody><tr><td>-m</td><td>改变档案的修改时间记录</td></tr><tr><td>-r</td><td>使用参考档的时间记录</td></tr><tr><td>-d</td><td>设定时间与日期，可以使用各种不同的格式</td></tr></tbody></table><p>例子</p><ul><li># touch file</li><li># touch -r source_file target_file</li></ul><h4 id="命令-cp"><a href="#命令-cp" class="headerlink" title="命令 cp"></a>命令 cp</h4><p>作用：文件或目录的复制</p><p>格式：cp [选项] 原路径… 目标路径</p><table><thead><tr><th>-a</th><th>复制目录时，保留链接、文件属性，并复制目录下的所有内容</th></tr></thead><tbody><tr><td>-f</td><td>覆盖已存在的目标文件而不进行提示</td></tr><tr><td>-p</td><td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td></tr><tr><td>-r</td><td>递归复制目录中的所有内容，包括子目录</td></tr></tbody></table><p>例子</p><ul><li>cp file1 file2</li><li>cp file1 dir1</li><li>cp -r dir1 dir2</li></ul><h4 id="命令-mv"><a href="#命令-mv" class="headerlink" title="命令 mv"></a>命令 mv</h4><p>作用：移动文件或目录(重命名)</p><p>格式： mv [选项] 原路径… 目标路径</p><table><thead><tr><th>-i</th><th>目标路径如果同名，先询问是否覆盖</th></tr></thead><tbody><tr><td>-f</td><td>覆盖已经存在的目标文件而不给提示</td></tr><tr><td>-n</td><td>不要覆盖任何已存在的文件或目录</td></tr></tbody></table><p>例子</p><ul><li><p>mv file1 file2</p></li><li><p>mv file1 dir1</p></li><li><p>mv dir1 dir2</p></li></ul><h4 id="命令-cat"><a href="#命令-cat" class="headerlink" title="命令 cat"></a>命令 cat</h4><p>作用：连接文件并打印到标准输出设备上</p><p>格式： cat [选项] &lt;文件&gt; …</p><table><thead><tr><th>-n</th><th>给每行编号</th></tr></thead><tbody><tr><td>-b</td><td>除了空白行，给每行编号</td></tr></tbody></table><p>例</p><ul><li># cat file1 file2</li><li># cat -n file1 file2</li></ul><h4 id="命令-more"><a href="#命令-more" class="headerlink" title="命令 more"></a>命令 more</h4><p>作用：分页显示文件内容</p><p>格式： more [选项] &lt;文件&gt;…</p><table><thead><tr><th>+n</th><th>从第 n 行开始显示</th></tr></thead><tbody><tr><td>-s</td><td>把连续的多行空行显示为一行</td></tr></tbody></table><p>注意点：<strong>一次性加载,只能往下翻</strong></p><p>基本操作</p><ul><li>q：退出</li><li>空格：下一页</li><li>回车： 下一行</li></ul><h4 id="命令-less"><a href="#命令-less" class="headerlink" title="命令 less"></a>命令 less</h4><p>作用：分页显示文件内容</p><p>格式： less [选项] &lt;文件&gt;…</p><table><thead><tr><th>-e</th><th>当文件显示结束后，自动退出</th></tr></thead><tbody><tr><td>-f</td><td>强迫打开特殊文件</td></tr><tr><td>-i</td><td>忽略搜索时的大小写</td></tr><tr><td>-N</td><td>显示每行的行号</td></tr><tr><td>-s</td><td>显示连续空行为一行</td></tr></tbody></table><p>注意点：<strong>支持上下翻,按需加载</strong></p><p>基本操作</p><ul><li>q：退出</li><li>空格：下一页</li><li>回车： 下一行</li><li>上下移动键：上下移动</li></ul><h4 id="命令-head"><a href="#命令-head" class="headerlink" title="命令 head"></a>命令 head</h4><p>作用：显示文件的开头的内容。在默认情况下显示文件的前 10 行内容</p><p>格式： head [选项] &lt;文件&gt;</p><table><thead><tr><th>-q</th><th>隐藏文件名</th></tr></thead><tbody><tr><td>-v</td><td>显示文件名</td></tr><tr><td>-c&lt;数目&gt;</td><td>显示的字节数</td></tr><tr><td>-n&lt;行数&gt;</td><td>显示的行数</td></tr></tbody></table><p>例子</p><ul><li># head file1</li><li># head -5 file1</li><li># head -n 5 file1</li><li># head -c 20 file1</li></ul><h4 id="命令-tail"><a href="#命令-tail" class="headerlink" title="命令 tail"></a>命令 tail</h4><p>作用：显示文件的结尾的内容。在默认情况下显示文件的最后 10 行内容</p><p>格式： tail [选项] &lt;文件&gt;</p><table><thead><tr><th>-f</th><th>当文件变化时输出文件新增内容</th></tr></thead><tbody><tr><td>-c&lt;数目&gt;</td><td>显示的字节数</td></tr><tr><td>-n&lt;行数&gt;</td><td>显示的行数</td></tr><tr><td>-v</td><td>显示详细的处理信息</td></tr></tbody></table><p>例子</p><ul><li># tail file1</li><li># tail -n 5 file1</li><li># tail -5 file1</li><li># tail -c 50 file1</li><li># tail -f file1</li></ul><h3 id="文件类型、相对路径、绝对路径、用户主目录、特殊目录、当前目录、工作目录"><a href="#文件类型、相对路径、绝对路径、用户主目录、特殊目录、当前目录、工作目录" class="headerlink" title="文件类型、相对路径、绝对路径、用户主目录、特殊目录、当前目录、工作目录"></a>文件类型、相对路径、绝对路径、用户主目录、特殊目录、当前目录、工作目录</h3><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><ul><li>普通文件：[ - ]<br>纯文字文件（ascii）或 二进制文件</li><li>目录： [ d ]</li><li>链接文件： [ l ]</li><li>设备文件：<br>区块设备文件：[ b ];<br>字符设备文件：[ c ]</li><li>管道文件： [ p ]</li><li>Socket 文件： [ s ]</li></ul><h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><p><strong>指从“根”开始的路径，也称为完全路径</strong> # cd /usr/local/bin</p><h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><p><strong>指从用户工作目录开始的路径</strong> # cd /usr# cd local/bin</p><h4 id="特殊目录"><a href="#特殊目录" class="headerlink" title="特殊目录"></a>特殊目录</h4><ul><li><strong>“.”代表该目录自己</strong></li><li><strong>“..”代表该目录的父目录</strong></li><li><strong>对于根目录，“.”和“..”都代表其自己</strong></li></ul><h4 id="工作目录-当前目录"><a href="#工作目录-当前目录" class="headerlink" title="工作目录/当前目录"></a>工作目录/当前目录</h4><p>用户登录系统后，某一时刻处在的目录，也称为当前目录</p><h4 id="用户主目录"><a href="#用户主目录" class="headerlink" title="用户主目录"></a>用户主目录</h4><ul><li>添加用户时为该用户建立起来的目录</li><li>每个用户都有自己的主目录 （普通用户一般在/home 下，root 用户在/root 下）</li><li><strong>用户主目录可以用符号 ~表示</strong></li><li>快速回到当前用户的主目录 cd ~</li></ul><h2 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h2><h3 id="用户类型"><a href="#用户类型" class="headerlink" title="用户类型"></a>用户类型</h3><ul><li>超级用户<br>root，根用户，有最高的权限，可以对 linux 做任何操作</li><li>普通用户<br>受限的权限，没有对系统的完全控制权，用户之间私人的资源是相互隔离的</li><li>系统用户<br>与系统和程序服务相关的用户<br>默认情况下，这些特殊用户的无法登录的，如果给这些用户授权登录口令后，就可以使这些用户登录系统</li></ul><h3 id="etc-passwd-作用和内容"><a href="#etc-passwd-作用和内容" class="headerlink" title="/etc/passwd 作用和内容"></a>/etc/passwd 作用和内容</h3><p>用户信息文件</p><ul><li>每一行存储一个用户的账号信息</li><li>用户名：加密密码：用户 ID：用户组 ID：用户信息：用户主目录：登录 Shell</li><li>超级用户 root 的 UID 是 0</li><li>系统用户的 UID 在 1000 以内</li><li>普通用户的 UID 从 1000 开始往上编号</li></ul><h3 id="etc-shadow-etc-group-作用"><a href="#etc-shadow-etc-group-作用" class="headerlink" title="/etc/shadow /etc/group 作用"></a>/etc/shadow /etc/group 作用</h3><h4 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h4><ul><li>口令文件</li><li>每一行存储一个用户的登录密码信息，加密</li><li>只有 root 用户才能读取这个文件</li></ul><h4 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h4><ul><li>每一行记录系统中的用户组信息</li><li>组名：密码字段：用户组 ID：用户名列表</li><li>用户名列表用冒号分隔多个用户名</li><li>默认情况下，创建用户的时候，系统会自动创建一个同名的组，作为该用户的主组。</li></ul><h3 id="useradd、passwd、usermod、userdel、groupadd、groupdel、chmod、chown、chgrp、ln、tar、gzip、unzip、awk、sed、cut、tr、find、grep"><a href="#useradd、passwd、usermod、userdel、groupadd、groupdel、chmod、chown、chgrp、ln、tar、gzip、unzip、awk、sed、cut、tr、find、grep" class="headerlink" title="useradd、passwd、usermod、userdel、groupadd、groupdel、chmod、chown、chgrp、ln、tar、gzip、unzip、awk、sed、cut、tr、find、grep"></a>useradd、passwd、usermod、userdel、groupadd、groupdel、chmod、chown、chgrp、ln、tar、gzip、unzip、awk、sed、cut、tr、find、grep</h3><h4 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523125911519.png" alt="image-20230523125911519"></p><p>例子</p><ul><li># useradd user1</li><li># useradd -d /home/user1024 -u 1024 -G user1 user2</li></ul><h4 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h4><p>作用：修改密码</p><p>格式：passwd [用户名]</p><p>普通用户只能修改自己密码</p><p>root 可以修改其他人</p><p>例子</p><ul><li># passwd</li><li># passwd user1</li></ul><p>高级应用-无交互设置密码</p><p>echo xxx | passwd –stdin root</p><h4 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523130139601.png" alt="image-20230523130139601"></p><p>例子</p><ul><li># usermod -u 2048 user2</li><li># usermod -d /home/user2048 user2</li></ul><h4 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h4><p>作用：删除用户</p><p>格式：userdel [-r] 用户名</p><p><strong>root 权限</strong></p><p>例子</p><ul><li># userdel user2</li><li># userdel -r user1 删除与用户相关的文件和目录,如用户家目录,日志,邮箱等</li></ul><h4 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h4><p>作用：增加用户组</p><p>格式：groupadd [-g] 组名</p><p><strong>root 权限</strong></p><p>例子</p><ul><li># groupadd user3</li><li># groupadd -g 1024 user1024 设置 GID</li></ul><h4 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h4><p>作用：删除用户组</p><p>格式：groupdel 组名</p><p><strong>root 权限</strong></p><p>例子 # groupdel user3</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523135729391.png" alt="image-20230523135729391"></p><p>例子</p><ul><li># chmod a=rwx,u-x,g-wx,o-rwx a.txt</li><li># chmod 640 a.txt</li><li># chmod -R 765 dir1</li></ul><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><p>作用：改变指定目录或文件的所属用户、所属组</p><p>格式：chown [-R] 用户名[:组名] 路径</p><p><strong>root 权限</strong></p><p>例子</p><ul><li># chown wilson a.txt</li><li># chown wilson:wilson a.txt</li><li># chown -R wilson dir1</li></ul><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><p>作用：改变指定目录或文件的所属组。</p><p>格式：chgrp [-R] 组名 路径</p><p><strong>root 权限</strong></p><p>例子</p><ul><li># chgrp wilson a.txt</li><li># chgrp -R wilson dir1</li></ul><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523140331387.png" alt="image-20230523140331387"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523163439730.png" alt="image-20230523163439730"></p><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>作用：备份文件</p><p>格式：tar [选项] 压缩文件名 路径</p><table><thead><tr><th>-c</th><th>创建备份</th></tr></thead><tbody><tr><td>-C path</td><td>切换到指定目录</td></tr><tr><td>-f</td><td>指定备份文件</td></tr><tr><td>-t</td><td>测试备份文件</td></tr><tr><td>-v</td><td>显示指令执行过程</td></tr><tr><td>-x</td><td>从备份中还原文件</td></tr><tr><td>-z</td><td>通过 gzip 指令处理备份文件</td></tr></tbody></table><p>例子</p><ul><li># tar cvf dir1.tar dir1</li><li># tar xvf dir1.tar</li><li># tar xvf dir1.tar -C /tmp</li><li># tar zcvf dir1.tar.gz dir1</li><li># tar zxvf dir1.tar.gz</li></ul><p>f 必须放到最后</p><p>压缩 tar -zcvf 压缩文件名 包内文件路径</p><p>解压 tar -zxvf 压缩文件名</p><h4 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h4><p>作用：用于压缩文件</p><p>格式：gzip [选项] 文件…</p><table><thead><tr><th>-d</th><th>解开压缩文件</th></tr></thead><tbody><tr><td>-l</td><td>列出压缩文件的相关信息</td></tr><tr><td>-r</td><td>递归处理指定目录</td></tr><tr><td>-v</td><td>显示指令执行过程</td></tr><tr><td>-t</td><td>测试压缩文件是否有误</td></tr></tbody></table><p>例子</p><ul><li># gzip dir1</li><li># gzip -drv dir1</li></ul><h4 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h4><p>作用：用于解压缩 zip 文件</p><p>格式：unzip [选项] 路径</p><table><thead><tr><th>-n</th><th>解压时不要覆盖原有文件</th></tr></thead><tbody><tr><td>-l</td><td>列出压缩文件的相关信息</td></tr><tr><td>-d dir</td><td>指定解压时存放的目录</td></tr><tr><td>-v</td><td>显示指令执行过程</td></tr><tr><td>-t</td><td>测试压缩文件是否有误</td></tr></tbody></table><p>例子</p><ul><li># unzip a.txt.zip</li><li># unzip -d /tmp a.txt.zip</li></ul><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>提取列数据 用于格式化输出，将数据按照我们想要的方式来显示，并且可以做一些基本的统计工作。</p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523164037934.png" alt="image-20230523164037934"></p><p>grep 行截取</p><p>cut（制表符分隔） awk（空格、制表符分隔） 列截取</p><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>作用：自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等</p><p>格式：sed [选项] 处理格式路径</p><table><thead><tr><th>a</th><th>在指定行号之后插入</th></tr></thead><tbody><tr><td>c</td><td>整行替换</td></tr><tr><td>s</td><td>匹配替换</td></tr><tr><td>i</td><td>在指定行号位置插入</td></tr><tr><td>d</td><td>删除</td></tr></tbody></table><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523164526132.png" alt="image-20230523164526132" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523164708051.png" alt="image-20230523164708051" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523164816395.png" alt="image-20230523164816395" style="zoom:50%;" /><p>sed 是一种几乎包括在所有 UNIX 平台的轻量级流编辑器。sed 主要是用来将数据进行选取、替换、删除、新增的命令。</p><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>作用：从指定文件中过滤或提取特定内容，并显示在当前屏幕上</p><p>格式：cut [选项] 路径</p><table><thead><tr><th>-b</th><th>以字节为单位进行分割</th></tr></thead><tbody><tr><td>-c</td><td>以字符为单位进行分割</td></tr><tr><td>-d</td><td>自定义分隔符，默认为制表符</td></tr><tr><td>-f</td><td>与-d 一起使用，指定显示哪个区域</td></tr></tbody></table><p>例子</p><ul><li>自定义分隔符,指定显示哪个区域<ul><li># cut -d: -f1,3,5 /etc/passwd</li><li># cut -d: -f 1-5 /etc/passwd</li></ul></li><li>以字符为单位进行分割<ul><li># cut -c2-5 /etc/passwd</li><li># cut -c2,5,7 /etc/passwd</li></ul></li></ul><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>作用：用于转换或删除文件中的字符</p><p>格式：tr [-d] 字符串 1 字符串 2</p><p>例子</p><ul><li># cat /etc/passwd | tr ‘a-z’ ‘A-Z’</li><li># tr ‘a-z’ ‘A-Z’ &lt; /etc/passwd</li><li># tr -d ‘a-c’ &lt; test.txt</li></ul><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>作用：查找文件或者目录</p><p>格式：find 路径 [选项] 表达式</p><table><thead><tr><th>-amin n</th><th>在过去 n<strong>分钟</strong>内被<strong>读取</strong>过的文件</th></tr></thead><tbody><tr><td>-atime n</td><td>在过去 n<strong>天</strong>内被<strong>读取</strong>过的文件</td></tr><tr><td>-cmin n</td><td>在过去 n<strong>分钟</strong>内被<strong>修改</strong>过的文件</td></tr><tr><td>-ctime n</td><td>在过去 n<strong>天</strong>内被<strong>修改</strong>过的文件</td></tr><tr><td>-type c</td><td>文件<strong>类型</strong>是 c 的文件</td></tr><tr><td>-perm p</td><td>文件<strong>权限</strong>为 p 的文件</td></tr><tr><td>-name n</td><td><strong>文件名</strong>为 n 的文件</td></tr></tbody></table><p>例子</p><ul><li># find . -name “*.conf”</li><li># find / -perm 765 -name “*.txt”</li><li># find /etc -type f -exec ls -l ‘{}’ ;<ul><li>查找普通格式的文件</li><li>执行命令</li></ul></li></ul><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523165809018.png" alt="image-20230523165809018"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523170104965.png" alt="image-20230523170104965"></p><h3 id="软连接和硬连接的区别和联系"><a href="#软连接和硬连接的区别和联系" class="headerlink" title="软连接和硬连接的区别和联系"></a>软连接和硬连接的区别和联系</h3><h4 id="硬连接（hard-link）"><a href="#硬连接（hard-link）" class="headerlink" title="硬连接（hard link）"></a>硬连接（hard link）</h4><p>​ 给文件一个<strong>副本</strong>（别名），同时建立两者之间的连接关系，修改其中一个，与其连接的文件同时被修改，如果删除其中一个，其余的文件不受影响。磁盘上只有一份数据。<strong>硬链接是存在同一个文件系统中</strong>。</p><h4 id="软连接-symbolic-link"><a href="#软连接-symbolic-link" class="headerlink" title="软连接(symbolic link)"></a>软连接(symbolic link)</h4><p>​ 软链接的方式则是产生一个特殊的文件，该文件的内容是指向另一个文件的位置。它只是一个<strong>快捷方式</strong>，删除了源文件，这个连接文件就没用了。<strong>软链接可以跨越不同的文件系统。</strong></p><h4 id="区别于联系"><a href="#区别于联系" class="headerlink" title="区别于联系"></a>区别于联系</h4><ul><li>适用场景</li><li>inode 节点</li><li>链接数</li><li>文件的属性</li><li>对链接进行操作（修改，删除）对原文件的影响</li><li>对原文件进行操作（修改，删除）对链接的影响</li><li><strong>需要指定绝对路径，否则链接失效</strong></li></ul><h3 id="常见正则表达式"><a href="#常见正则表达式" class="headerlink" title="常见正则表达式"></a>常见正则表达式</h3><ul><li><p>^<br>锚定行的开始，如：’^grep’ 匹配所有以 grep 开头的行</p></li><li><p>$<br>锚定行的结束，如：’grep$’ 匹配所有以 grep 结尾的行</p></li><li><p>.<br>匹配一个非换行符的字符，如：’gr.p’ 匹配 gr 后接一个任意字符，然后是 p</p></li><li><ul><li>匹配 0 个或多个先前字符，如：’*grep’ 匹配所有一个或多个空格后紧跟 grep 的行。.*一起用代表任意字符</li></ul></li><li><p>[]<br>匹配一个指定范围内的字符，如：’[Gg]rep’ 匹配 Grep 和 grep</p></li><li><p>[^]<br>匹配一个不在指定范围内的字符，如：’[^A-F]rep’ 匹配不包含 A-F 的一个字母开头，紧跟 rep 的行</p></li><li><p>\(..\)<br>标记匹配字符，如：’\(love\)’ ，love 被标记为 1</p></li><li><p>\&lt;<br>锚定单词的开始，如：’\&lt;grep’匹配包含以 grep 开头的单词的行</p></li><li><p>\&gt;<br>锚定单词的结束，如：’grep\&gt;’匹配包含以 grep 结尾的单词的行</p></li><li><p>x\{m\}<br>重复字符 x，m 次，如：’o\{5\}’ 匹配包含 5 个 o 的行</p></li><li><p>x\{m,\}<br>重复字符 x，至少 m 次，如：’o\{5,\}’ 匹配至少有 5 个 o 的行</p></li><li><p>x\{m,n\}<br>重复字符 x，至少 m 次，不多于 n 次，如：’o\{5,10\}’匹配 5–10 个 o 的行</p></li><li><p>\w</p><p>匹配文字和数字字符，也就是[A-Za-z0-9]，如：’G\w*p’匹配以 G 后跟零个或多个文字或数字字符，然后是 p</p></li><li><p>\W</p><p>\w 的反置形式，匹配一个或多个非单词字符，如点号句号等</p></li><li><p>\b</p><p>单词锁定符，如: ‘\bgrep\b’只匹配 grep</p></li></ul><h2 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h2><h3 id="cal、date、wc、sort、which、whereis、su、yum、sudo"><a href="#cal、date、wc、sort、which、whereis、su、yum、sudo" class="headerlink" title="cal、date、wc、sort、which、whereis、su、yum、sudo"></a>cal、date、wc、sort、which、whereis、su、yum、sudo</h3><h4 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h4><p>作用：打印日期</p><p>格式：cal</p><table><thead><tr><th>-3</th><th>显示最近三个月的日历</th></tr></thead><tbody><tr><td>-s</td><td>将星期天作为月的第一天</td></tr><tr><td>-m</td><td>将星期一作为月的第一天</td></tr><tr><td>-y</td><td>显示当年日历</td></tr></tbody></table><p>例子：</p><ul><li># cal</li><li># cal -3</li><li># cal 2 2022</li></ul><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><p>作用：显示或设定系统的日期与时间</p><p>格式：date [选项] 时间格式</p><table><thead><tr><th>%H</th><th>小时(00..23)</th></tr></thead><tbody><tr><td>%M</td><td>分钟(00..59)</td></tr><tr><td>%S</td><td>秒(00..60)</td></tr><tr><td>%Y</td><td>完整月份(0000..9999)</td></tr><tr><td>%m</td><td>月份(01..12)</td></tr><tr><td>%d</td><td>日(01..31)</td></tr></tbody></table><p>例子</p><ul><li># date</li><li># date ’+%Y-%m-%d %H:%M:%S’</li></ul><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>作用：默认统计文件内的行／字和字节数</p><p>格式：wc [选项] 文件路径</p><table><thead><tr><th>-c</th><th>按字节统计</th></tr></thead><tbody><tr><td>-l</td><td>按行数统计</td></tr><tr><td>-m</td><td>按字符统计</td></tr><tr><td>-w</td><td>按单词统计</td></tr></tbody></table><p>例子</p><ul><li># wc /etc/passwd</li><li># cat /etc/passwd | wc -l</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523171621006.png" alt="image-20230523171621006"></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>作用：对内容排序</p><p>格式：sort [选项] 文件路径</p><table><thead><tr><th>-f</th><th>排序时，将小写字母视为大写字母</th></tr></thead><tbody><tr><td>-n</td><td>按照数值大小排序</td></tr><tr><td>-u</td><td>去重排序</td></tr><tr><td>-o file</td><td>将排序后的结果存入指定的文件</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr></tbody></table><p>例子</p><ul><li># sort /etc/passwd</li><li># sort -r /etc/passwd</li><li># sort -o out.txt -n /etc/passwd</li></ul><p>sort 以空格为分隔符，将一行分割为多个关键字对文件进行排序，它并没有对文件内容进行实际排序，只是将文件内容有序输出</p><h4 id="which、whereis"><a href="#which、whereis" class="headerlink" title="which、whereis"></a>which、whereis</h4><p>作用：查找文件</p><p>格式： which / whereis 命令</p><p>例子</p><ul><li># which useradd</li><li># whereis useradd</li><li># which ls</li><li># whereis ls</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523172245039.png" alt="image-20230523172245039"></p><h4 id="su"><a href="#su" class="headerlink" title="su"></a>su</h4><p>作用：变更为其他使用者的身份。除 root 外，需要键入该使用者的密码</p><p>格式： su [选项] [用户名]</p><p>例子</p><ul><li># su</li><li># su tak</li><li># su -c ls tak</li><li># su - tak -c ls 变更账号为 tak 的使用者，并执行指令（ls）后再变回原来使用者</li></ul><h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><p>作用：以系统管理者的身份执行指令</p><p>格式： sudo 命令</p><p>CentOS7 默认没有普通用户具有 sudo 权限</p><p>例子 # sudo cat /etc/shadow</p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523172625558.png" alt="image-20230523172625558"></p><h3 id="vi-三种模式的功能、切换"><a href="#vi-三种模式的功能、切换" class="headerlink" title="vi 三种模式的功能、切换"></a>vi 三种模式的功能、切换</h3><p>命令模式</p><ul><li>启动 vi 后默认模式</li><li>按下 ESC 键可进入命令模式</li><li>输入的字符被当成命令，字符不回显</li></ul><p>插入模式</p><ul><li>命令模式下通过 i、a、o、c、r、s 等命令进入</li><li>输入的字符被当成文本内容，显示在屏幕上</li></ul><p>末行模式</p><ul><li>命令模式下通过:、/、?等命令进入</li><li>显示在屏幕的最后一行</li><li>命令执行后，自动切换到命令模式</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523194304373.png" alt="image-20230523194304373"></p><h3 id="末行模式：保存、退出、显示-取消行号、搜索、替换"><a href="#末行模式：保存、退出、显示-取消行号、搜索、替换" class="headerlink" title="末行模式：保存、退出、显示/取消行号、搜索、替换"></a>末行模式：保存、退出、显示/取消行号、搜索、替换</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523194520961.png" alt="image-20230523194520961"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523194648929.png" alt="image-20230523194648929"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523194718604.png" alt="image-20230523194718604"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523194821924.png" alt="image-20230523194821924"></p><h3 id="命令模式：光标移动、删除恢复、复制粘贴、替换、切换到插入模式（含课外补充内容、课外作业）"><a href="#命令模式：光标移动、删除恢复、复制粘贴、替换、切换到插入模式（含课外补充内容、课外作业）" class="headerlink" title="命令模式：光标移动、删除恢复、复制粘贴、替换、切换到插入模式（含课外补充内容、课外作业）"></a>命令模式：光标移动、删除恢复、复制粘贴、替换、切换到插入模式（含课外补充内容、课外作业）</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523194922284.png" alt="image-20230523194922284"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195049270.png" alt="image-20230523195049270"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195129791.png" alt="image-20230523195129791"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195217253.png" alt="image-20230523195217253"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195246239.png" alt="image-20230523195246239"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195347664.png" alt="image-20230523195347664"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195438758.png" alt="image-20230523195438758"></p><h4 id="课外补充"><a href="#课外补充" class="headerlink" title="课外补充"></a>课外补充</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195743675.png" alt="image-20230523195743675"></p><h4 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523195840553.png" alt="image-20230523195840553"></p><h3 id="vi-与-shell-交互"><a href="#vi-与-shell-交互" class="headerlink" title="vi 与 shell 交互"></a>vi 与 shell 交互</h3><p>在末行模式下用“！”符号来访问 Linux 的 shell</p><ul><li>例如</li><li>:!cat /etc/passwd | more</li><li>:! /bin/bash</li></ul><h3 id="vi-冲突处理"><a href="#vi-冲突处理" class="headerlink" title="vi 冲突处理"></a>vi 冲突处理</h3><ul><li>每次打开文件会创建一个名为 *.swp 的临时文件</li><li>当多界面编辑、vi 异常退出时会导致异常</li><li>删除 *.swp 即可</li></ul><h3 id="文本格式转换"><a href="#文本格式转换" class="headerlink" title="文本格式转换"></a>文本格式转换</h3><p>unix2dos（linux 转 window）、dos2unix（window 转 linux）</p><ul><li>使用</li><li>unix2dos | dos2unix filename #格式转换后覆盖源文件</li><li>unix2dos | dos2unix -n filename newFilename #格式转换后存为新文件</li></ul><h2 id="第六讲"><a href="#第六讲" class="headerlink" title="第六讲"></a>第六讲</h2><h3 id="ifconfig、ifup、ifdown、ping、netstat、service、chkconfig"><a href="#ifconfig、ifup、ifdown、ping、netstat、service、chkconfig" class="headerlink" title="ifconfig、ifup、ifdown、ping、netstat、service、chkconfig"></a>ifconfig、ifup、ifdown、ping、netstat、service、chkconfig</h3><h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523210204529.png" alt="image-20230523210204529"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523210546615.png" alt="image-20230523210546615"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523210604759.png" alt="image-20230523210604759"></p><h4 id="ifup、ifdown"><a href="#ifup、ifdown" class="headerlink" title="ifup、ifdown"></a>ifup、ifdown</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523210404221.png" alt="image-20230523210404221"></p><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>作用：网络连通性测试</p><p>格式：ping [选项] &lt;目的主机名或 IP 地址&gt;</p><table><thead><tr><th>-c &lt;完成次数&gt;</th><th>设置完成要求回应的次数</th></tr></thead><tbody><tr><td>-s &lt;数据包大小&gt;</td><td>设置数据包的大小</td></tr><tr><td>-t &lt;存活数值&gt;</td><td>设置存活数值 TTL 的大小</td></tr><tr><td>-v</td><td>详细显示指令的执行过程</td></tr></tbody></table><p>例子</p><ul><li># ping <a href="http://www.baidu.com/">www.baidu.com</a></li><li># ping -c 4 <a href="http://www.baidu.com/">www.baidu.com</a></li></ul><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>作用:用于显示网络状态</p><p>格式: netstat [选项]</p><table><thead><tr><th>-a 或–all</th><th>显示所有连线中的 Socket</th></tr></thead><tbody><tr><td>-A&lt;网络类型&gt;或–&lt;网络类型&gt;</td><td>列出该网络类型连线中的相关地址</td></tr><tr><td>-c 或–continuous</td><td>持续列出网络状态</td></tr><tr><td>-e 或–extend</td><td>显示网络其他相关信息</td></tr><tr><td>-l 或–listening</td><td>显示监控中的服务器的 Socket</td></tr><tr><td>-n 或–numeric</td><td>直接使用 IP 地址，而不通过域名服务器</td></tr><tr><td>-p 或–programs</td><td>显示正在使用 Socket 的程序识别码和程序名称</td></tr><tr><td>-t 或–tcp</td><td>显示 TCP 传输协议的连线状况</td></tr><tr><td>-u 或–udp</td><td>显示 UDP 传输协议的连线状况</td></tr><tr><td>-v 或–verbose</td><td>显示指令执行过程</td></tr></tbody></table><p>例子</p><ul><li># netstat -a （显示所有连线中的 Socket）</li><li># netstat -aux （列出所有监听 UNIX 端口和 udp 端口）</li><li># netstat -ntlp | grep port （查看端口使用）</li></ul><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>作用：用于对系统服务进行管理</p><p>格式：service 服务名 [ start | stop | restart | status ]</p><p>例子</p><ul><li># service sshd restart</li><li># service atd status</li></ul><h4 id="chkconfig"><a href="#chkconfig" class="headerlink" title="chkconfig"></a>chkconfig</h4><p>作用：用于检查和设置系统的各种服务，<strong>设置启动项</strong></p><p>格式：chkconfig [选项] 服务名 [状态]</p><table><thead><tr><th>–add</th><th>添加指定的新服务</th></tr></thead><tbody><tr><td>–del</td><td>删除指定服务</td></tr><tr><td>–level&lt;运行级别编号&gt;</td><td>改变服务的运行级别及启动信息</td></tr><tr><td>–list</td><td>显示所有或指定服务，以及他们在每个运行级别是否启动</td></tr></tbody></table><p>提供了一个维护/etc/rc[0~6] d 文件夹的命令行工具，它减轻了系统直接管理这些文件夹中的符号连接的负担</p><p>chkconfig 不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接，需要重启才能生效</p><p>例子</p><ul><li># chkconfig –list</li><li># chkconfig –add mysql</li><li># chkconfig –level 2345 mysql on</li></ul><h4 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h4><p>主要负责控制 systemd 系统和服务管理器</p><p>是一个系统管理守护进程、工具和库的集合，用于取代 System V、service 和 chkconfig 命令</p><blockquote><p>service 对比</p><p>例子</p><p># systemctl start network.service</p><p># systemctl restart sshd</p><table><thead><tr><th>**daemon****命令**</th><th>**systemctl****命令**</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>service [服务] start</td><td>systemctl start [unit type]</td><td>启动服务</td></tr><tr><td>service [服务] stop</td><td>systemctl stop [unit type]</td><td>停止服务</td></tr><tr><td>service [服务] restart</td><td>systemctl restart [unit type]</td><td>重启服务</td></tr></tbody></table></blockquote><blockquote><p>chkconfig 对比</p><p>例子</p><p># systemctl enable nginx.service</p><p># systemctl disable sshd</p><table><thead><tr><th>**daemon****命令**</th><th>**systemctl****命令**</th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>chkconfig [服务] on</td><td>systemctl enable [unit type]</td><td>设置服务开机启动</td></tr><tr><td>chkconfig [服务] off</td><td>systemctl disable [unit type]</td><td>设备服务禁止开机启动</td></tr></tbody></table></blockquote><h3 id="网络配置文件的各自作用、设置静态-IP-方法"><a href="#网络配置文件的各自作用、设置静态-IP-方法" class="headerlink" title="网络配置文件的各自作用、设置静态 IP 方法"></a>网络配置文件的各自作用、设置静态 IP 方法</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523211048045.png" alt="image-20230523211048045"></p><h4 id="设置静态-IP-方法"><a href="#设置静态-IP-方法" class="headerlink" title="设置静态 IP 方法"></a>设置静态 IP 方法</h4><h3 id="开机自启动三种方式"><a href="#开机自启动三种方式" class="headerlink" title="开机自启动三种方式"></a>开机自启动三种方式</h3><h4 id="开机自启动-etc-rc-d-rc-local"><a href="#开机自启动-etc-rc-d-rc-local" class="headerlink" title="开机自启动-/etc/rc.d/rc.local"></a>开机自启动-/etc/rc.d/rc.local</h4><ol><li><p>赋予脚本可执行权限</p><p># chmod +x /opt/script/autostart.sh</p></li><li><p>在 /etc/rc.d/rc.local 末尾增加想要执行的脚本内容</p><p># su - user -c ‘/opt/script/autostart.sh’</p></li><li><p>给 /etc/rc.d/rc.local 赋予可执行权限</p><p># chmod +x /etc/rc.d/rc.local</p></li></ol><h4 id="开机自启动-chkconfig"><a href="#开机自启动-chkconfig" class="headerlink" title="开机自启动-chkconfig"></a>开机自启动-chkconfig</h4><ol><li><p>将脚本移动到 /etc/rc.d/init.d 目录下</p><p># mv /opt/script/autostart.sh /etc/rc.d/init.d</p></li><li><p>赋予脚本可执行权限</p><p># chmod +x /etc/rc.d/init.d/autostart.sh</p></li><li><p>添加脚本到开机自动启动项目中</p><p># cd /etc/rc.d/init.d</p><p># chkconfig –add autostart.sh</p><p># chkconfig autostart.sh on</p></li></ol><h4 id="开机自启动-systemctl"><a href="#开机自启动-systemctl" class="headerlink" title="开机自启动 - systemctl"></a>开机自启动 - systemctl</h4><p>默认情况下，服务通过 yum install 时，会自动配置好 unit 文件</p><p>默认在 /usr/lib/systemd/system 目录下</p><p>以 Jenkins 为例</p><p># systemctl enable jenkins.service</p><p># systemctl start jenkins.service</p><h2 id="第七讲"><a href="#第七讲" class="headerlink" title="第七讲"></a>第七讲</h2><h3 id="两个网络模式的区别与联系-含图-，如何选择"><a href="#两个网络模式的区别与联系-含图-，如何选择" class="headerlink" title="两个网络模式的区别与联系(含图)，如何选择"></a>两个网络模式的区别与联系(含图)，如何选择</h3><ul><li>独立的守护进程工作模式</li><li>基于 xinetd 的工作模式</li></ul><h4 id="独立的守护进程模式（stand-alone）"><a href="#独立的守护进程模式（stand-alone）" class="headerlink" title="独立的守护进程模式（stand-alone）"></a>独立的守护进程模式（stand-alone）</h4><ul><li>是 Unix 传统的 C/S 模式的访问模式</li><li>在 Client/Server 模式下，服务器监听（Listen）在一个特定的端口上等待客户连接，连接成功后服务器和客户端通过端口进行数据通信</li><li>守护进程的工作就是打开一个端口，并且等待（Listen）进入连接</li><li>如果客户端发起一个连接请求，守护进程就创建（Fork）一个子进程响应这个连接，而主进程继续监听其他的服务请求</li><li>运行独立的守护进程工作方式称作：stand-alone</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523230202319.png" alt="image-20230523230202319"></p><h4 id="基于-xinetd-的工作模式"><a href="#基于-xinetd-的工作模式" class="headerlink" title="基于 xinetd 的工作模式"></a>基于 xinetd 的工作模式</h4><ul><li>支持对 TCP、UDP、RPC 服务的管理</li><li>可以实施基于时间段的访问控制</li><li>功能完备的 log 功能，可以记录连接成功、连接失败的行为</li><li>能够有效地防止拒绝服务（DoS）的攻击</li><li>能够限制同时运行的同一类型的服务器的数目</li><li>能够限制 log 文件大小</li><li>能够将某个服务绑定在特定的系统接口上，从而实现只能允许私有网络访问某项服务</li><li>能够实现作为其它系统的代理</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523230545547.png" alt="image-20230523230545547"></p><ul><li><p>xinetd 能够同时监听多个指定的端口，在接受用户请求时，它能够根据用户请求的端口不同，启动不同的网络服务进程来处理这些用户请求</p></li><li><p>可以把 xinetd 看做一个管理启动服务的管理服务器，它决定把一个客户请求交给那个程序处理，然后启动相应的守护进程</p></li><li><p>运行单个 xinetd 就可以同时监听所有服务端口，这样就降低了系统开销，保护系统资源</p></li><li><p>但是对于访问量大、经常出现并发访问时，xinetd 想要频繁启动对应的网络服务进程，反而会导致系统性能下降</p></li><li><p>因此在选择基于哪种工作模式的时候，需要根据服务的使用情况具体情况具体分析</p></li></ul><h4 id="stand-alone-与-xinetd-区别与联系"><a href="#stand-alone-与-xinetd-区别与联系" class="headerlink" title="stand-alone 与 xinetd 区别与联系"></a>stand-alone 与 xinetd 区别与联系</h4><p>standalone 一次性启动，运行期间一直驻留在内存中，优点是对接入信号反应快，缺点是损耗了一定的系统资源，<br>因此经常应用于对实时反应要求较高的 专业 FTP 服务器.</p><p>xinetd 只在外部连接发送请求时才调用 FTP 进程，不适合应用在同时连接数量较多的系统。不占用系统资源。</p><p>反应速度：standalone &gt; xinetd<br>占用资源：standalone &gt; xinetd</p><h3 id="telnet-服务的配置过程、telnet-命令使用"><a href="#telnet-服务的配置过程、telnet-命令使用" class="headerlink" title="telnet 服务的配置过程、telnet 命令使用"></a>telnet 服务的配置过程、telnet 命令使用</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523231104338.png" alt="image-20230523231104338"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523231152022.png" alt="image-20230523231152022"></p><h3 id="ftp-两种工作模式的区别与联系-含图）"><a href="#ftp-两种工作模式的区别与联系-含图）" class="headerlink" title="ftp 两种工作模式的区别与联系(含图）"></a>ftp 两种工作模式的区别与联系(含图）</h3><ul><li>主动模式 PORT（服务器 主动连接 客户端）</li><li>被动模式 PASV （服务器 被动等待 客户端连接）</li></ul><h4 id="主动模式-PORT"><a href="#主动模式-PORT" class="headerlink" title="主动模式 PORT"></a>主动模式 PORT</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523231451091.png" alt="image-20230523231451091"></p><p>主动模式 PORT(服务器 主动连接 客户端 )</p><p>指的是 FTP 服务器“主动”去连接客户端的数据端口来传输数据</p><ol><li>客户端从一个任意的非特权端口 N（N&gt;1024）连接到 FTP 服务器的命令端口（即 tcp 21 端口）</li><li>客户端开始监听端口 N+1，并发送 FTP 命令“port N+1”到 FTP 服务器</li><li>服务器会从它自己的数据端口（20）“主动”连接到客户端指定的数据端口（N+1）</li><li>客户端就可以和 ftp 服务器建立数据传输通道了</li></ol><h4 id="被动模式-PASV"><a href="#被动模式-PASV" class="headerlink" title="被动模式 PASV"></a>被动模式 PASV</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523231742421.png" alt="image-20230523231742421"></p><p>被动模式 PASV(服务器 被动等待 客户端连接)</p><p>指的是 FTP 服务器“被动”等待客户端来连接自己的数据端口</p><ol><li>客户端打开两个任意的非特权本地端口（N &gt;1024 和 N+1）</li><li>第一个端口连接服务器的 21 端口，提交 PASV 命令</li><li>服务器会开启一个任意的非特权端口（P &gt; 1024），并发送给客户端</li><li>客户端发起从本地端口 N+1 到服务器的端口的连接用来传送数据。（注意此模式下的 FTP 服务器不需要开启 tcp 20 端口了）</li></ol><h3 id="ftp-的配置过程、ftp-命令的使用"><a href="#ftp-的配置过程、ftp-命令的使用" class="headerlink" title="ftp 的配置过程、ftp 命令的使用"></a>ftp 的配置过程、ftp 命令的使用</h3><h4 id="FTP-配置"><a href="#FTP-配置" class="headerlink" title="FTP 配置"></a>FTP 配置</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232101620.png" alt="image-20230523232101620"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232131480.png" alt="image-20230523232131480"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232225623.png" alt="image-20230523232225623"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232258255.png" alt="image-20230523232258255"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232341046.png" alt="image-20230523232341046"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232442040.png" alt="image-20230523232442040"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232613121.png" alt="image-20230523232613121"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232715347.png" alt="image-20230523232715347"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523232740672.png" alt="image-20230523232740672"></p><h4 id="FTP-命令"><a href="#FTP-命令" class="headerlink" title="FTP 命令"></a>FTP 命令</h4><p>ftp xx.xx.xx.xx | open xx.xx.xx.xx</p><p>get | mget <filename></p><p>put | mput <filename></p><p>binary | acsii 设置文件传输方式</p><p>cd 在远程主机切换目录</p><p>lcd 在本地主机切换目录</p><p>ls 在远程主机上执行 ls</p><p>mkdir 在远程主机上创建目录</p><p>close 关闭</p><p>quit 退出</p><p>匿名登录</p><p>ftp | anonymous</p><p>空</p><h2 id="第八讲"><a href="#第八讲" class="headerlink" title="第八讲"></a>第八讲</h2><h3 id="shell-程序的特点与用途"><a href="#shell-程序的特点与用途" class="headerlink" title="shell 程序的特点与用途"></a>shell 程序的特点与用途</h3><p>shell 是用户和系统内核之间的接口程序</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>shell 程序可以认为是将 shell 命令按照控制结构组织到一个文本文件中，批量的交给 shell 去执行</li><li>不同的 shell 解释器使用不同的 shell 命令语法</li><li>shell 程序解释执行，不生成可以执行的二进制文件</li></ul><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ul><li>可以帮助用户完成特定的任务，提高使用、维护系统的效率</li><li>可以更好的配置和使用 Linux，实现自动化运维</li></ul><h3 id="shell-程序的编写、执行和调试"><a href="#shell-程序的编写、执行和调试" class="headerlink" title="shell 程序的编写、执行和调试"></a>shell 程序的编写、执行和调试</h3><h4 id="如何执行"><a href="#如何执行" class="headerlink" title="如何执行"></a>如何执行</h4><ul><li><p>可以使用 /bin/bash filename</p></li><li><p>添加执行权限，指定路径执行</p><ul><li>chmod +x /path/filename</li><li>./path/filename</li></ul></li></ul><h4 id="程序编译和执行过程"><a href="#程序编译和执行过程" class="headerlink" title="程序编译和执行过程"></a>程序编译和执行过程</h4><p>一般步骤</p><ul><li>编辑文件</li><li>保存文件</li><li>将文件赋予可执行的权限</li><li>运行及排错</li></ul><p>常用到的命令</p><ul><li>vi 编辑、保存文件</li><li>ls -l 查看文件权限</li><li>chmod 改变程序执行权限</li><li>直接键入文件名运行文件</li></ul><p>一般结构</p><ul><li>shell 类型</li><li>函数</li><li>主过程</li></ul><h3 id="变量声明与使用、read、位置变量、-HOME、-PATH、-？"><a href="#变量声明与使用、read、位置变量、-HOME、-PATH、-？" class="headerlink" title="变量声明与使用、read、位置变量、$HOME、$PATH、$？"></a>变量声明与使用、read、位置变量、$HOME、$PATH、$？</h3><h4 id="变量的声明和使用"><a href="#变量的声明和使用" class="headerlink" title="变量的声明和使用"></a>变量的声明和使用</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523234011535.png" alt="image-20230523234011535"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523234041505.png" alt="image-20230523234041505"></p><blockquote><p>如果字符串里包含空格，就必须用引号把它们括起来</p><p>等号两边不能有空格!!!</p><p>默认情况下，所有输入的内容都是字符串</p></blockquote><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p>使用 read 将用户的输入赋值给变量</p><p>例子：</p><p># echo “Input something please:”</p><p># read something</p><p># echo ${something}</p><h4 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523234742173.png" alt="image-20230523234742173"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230523234856737.png" alt="image-20230523234856737"></p><p>有点类似形参与实参</p><p>$*   所有参数看做一个整体<br>$@ 所有参数不看做一个整体，而是区分对待</p><h4 id="环境变量（-HOME-PATH-）"><a href="#环境变量（-HOME-PATH-）" class="headerlink" title="环境变量（$HOME,$PATH,$?）"></a>环境变量（$HOME,$PATH,$?）</h4><table><thead><tr><th>环境变量</th><th>说明</th></tr></thead><tbody><tr><td>$HOME</td><td>用户的主目录</td></tr><tr><td>$IFS</td><td>内部的域分隔符，一般为空格符、制表符或换行符</td></tr><tr><td>$PATH</td><td>寻找命令或可执行文件的搜索路径列表，路径以冒号分隔</td></tr><tr><td>$$</td><td>Shell 脚本的进程号</td></tr><tr><td>$?</td><td>紧邻的前驱命令的返回值 0=成功 1=失败</td></tr><tr><td>$TERM</td><td>使用的终端类型</td></tr><tr><td>$SHELL</td><td>查看当前用户所使用的的 shell</td></tr></tbody></table><h3 id="双引号、单引号和倒引号的区别和联系"><a href="#双引号、单引号和倒引号的区别和联系" class="headerlink" title="双引号、单引号和倒引号的区别和联系"></a>双引号、单引号和倒引号的区别和联系</h3><h4 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h4><ul><li>字符串通常被放在双引号中</li><li>如果在参数中包含一个或多个空白字符，必须给参数加双引号</li><li>如果把一个带有$字符的变量放在双引号中，程序执行到该行时会把变量替换为它的值</li><li>可用\字符取消$的特殊含义</li></ul><h4 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h4><p>由单引号括起来的字符都作为普通字符出现</p><h4 id="倒引号"><a href="#倒引号" class="headerlink" title="倒引号"></a>倒引号</h4><p>倒引号括起来的字符串都被 shell 解释为命令行，在执行时 shell 会执行该命令行，并以它的标准输出结果取代整个倒引号部分</p><h3 id="简单数学运算、条件判断（字符串、数学）、逻辑运算"><a href="#简单数学运算、条件判断（字符串、数学）、逻辑运算" class="headerlink" title="简单数学运算、条件判断（字符串、数学）、逻辑运算"></a>简单数学运算、条件判断（字符串、数学）、逻辑运算</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524092042044.png" alt="image-20230524092042044"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524092118313.png" alt="image-20230524092118313"></p><h4 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524092757314.png" alt="image-20230524092757314"></p><table><thead><tr><th>常用字符串属性条件判断</th><th></th></tr></thead><tbody><tr><td>string_1 = string_2</td><td>如果 string_1 和 string_2 两个字符串相等则返回真，否则返回假；</td></tr><tr><td>string_1 != string_2</td><td>如果 string_1 和 string_2 两个字符串不相等则返回真，否则返回假；</td></tr><tr><td>-z string</td><td>如果字符串 string 的长度为 0 则返回真，否则返回假； zero</td></tr><tr><td>-n string</td><td>如果字符串 string 长度不为 0 则返回真，否则返回假；</td></tr><tr><td>string</td><td>同-n string，如果字符串 string 长度不为 0 返回真，否则返回假。</td></tr></tbody></table><table><thead><tr><th>常用的整数关系条件判断</th><th></th></tr></thead><tbody><tr><td>mum_1 –eq num_2</td><td>如果 num_1 和 num_2 相等则返回真，否则返回假；</td></tr><tr><td>mum_1 –ne num_2</td><td>如果 num_1 不等于 num_2 则返回真，否则返回假；</td></tr><tr><td>mum_1 –gt num_2</td><td>如果 num_1 大于 num_2 则返回真，否则返回假；</td></tr><tr><td>mum_1 –lt num_2</td><td>如果 num_1 小于 num_2 则返回真，否则返回假；</td></tr><tr><td>mum_1 –le num_2</td><td>如果 num_1 小于等于 num_2 则返回真，否则返回假；</td></tr><tr><td>mum_1 –ge num_2</td><td>如果 num_1 大于等于 num_2 则返回真，否则返回假；</td></tr></tbody></table><h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><ul><li>逻辑与-a：condition1 -a condition2，如果两个条件都为真，则结果为真</li><li>逻辑或-o：condition1 -o condition2，如果两个条件有一个为真，则结果为真</li><li>逻辑非!：! condition，结果与 condition 相反</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524093438791.png" alt="image-20230524093438791"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524093507699.png" alt="image-20230524093507699"></p><h3 id="if、casse、for、while、until"><a href="#if、casse、for、while、until" class="headerlink" title="if、casse、for、while、until"></a>if、casse、for、while、until</h3><h4 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h4><ul><li>分支结构</li><li>循环结构</li></ul><h4 id="常见分支结构"><a href="#常见分支结构" class="headerlink" title="常见分支结构"></a>常见分支结构</h4><ul><li>if</li><li>case</li></ul><h4 id="常见循环结构"><a href="#常见循环结构" class="headerlink" title="常见循环结构"></a>常见循环结构</h4><ul><li>for</li><li>while</li><li>until</li></ul><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524093847283.png" alt="image-20230524093847283"></p><h4 id="case"><a href="#case" class="headerlink" title="case"></a>case</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524093920737.png" alt="image-20230524093920737"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524093943991.png" alt="image-20230524093943991"></p><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524094042864.png" alt="image-20230524094042864"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524094103460.png" alt="image-20230524094103460"></p><h4 id="while-until"><a href="#while-until" class="headerlink" title="while/until"></a>while/until</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524094144449.png" alt="image-20230524094144449"></p><h3 id="要求可以-手写-shell-程序"><a href="#要求可以-手写-shell-程序" class="headerlink" title="要求可以 手写 shell 程序"></a>要求可以 手写 shell 程序</h3><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524094237375.png" alt="image-20230524094237375"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524094550550.png" alt="image-20230524094550550"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524094640412.png" alt="image-20230524094640412"></p><h2 id="第九讲"><a href="#第九讲" class="headerlink" title="第九讲"></a>第九讲</h2><h3 id="gcc-命令使用（一次编译、分开编译、不同目录、指定头文件）"><a href="#gcc-命令使用（一次编译、分开编译、不同目录、指定头文件）" class="headerlink" title="gcc 命令使用（一次编译、分开编译、不同目录、指定头文件）"></a>gcc 命令使用（一次编译、分开编译、不同目录、指定头文件）</h3><p>gcc：</p><ul><li><p>GNU project C and C++ compiler</p></li><li><p>GNU Compiler Collection</p></li></ul><p>GCC 文件扩展名规范</p><ul><li>.c 为后缀的文件，是 C 语言源代码文件</li><li>.h 为后缀的文件，是头文件</li><li>.i 为后缀的文件，是已经预处理过的 C 源代码文件</li><li>.s 为后缀的文件，是汇编语言源代码文件</li><li>.o 为后缀的文件，是编译后的目标文件</li></ul><p>基本使用格式 $ gcc [ 选项 ] &lt;文件名&gt;</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-o file</td><td>将经过 gcc 处理过的结果存为文件 file，这个结果文件可能是预处理文件、汇编文件、目标文件或者最终的可执行文件。假设被处理的源文件为 source.suffix，如果<strong>这个</strong>选项被省略了，那么生成的可执行文件<strong>默认</strong>名称为 a.out；目标文件默认名为 source.o；汇编文件默认名为 source.s；生成的预处理文件则发送到标准输出设备</td></tr><tr><td>-c</td><td>仅对源文件进行编译，不链接生成可执行文件。在对源文件进行查错时，或只需产生目标文件时可以使用该选项</td></tr><tr><td>-g[gdb]</td><td>在可执行文件中加入调试信息，方便进行程序的调试。如果使用中括号中的选项，表示加入 gdb 扩展的调试信息，方便使用 gdb 来进行调试</td></tr><tr><td>-O[0、1、2、3]</td><td>对生成的代码使用优化，中括号中的部分为优化级别，缺省的情况为 2 级优化，0 为不进行优化。注意，采用更高级的优化并不一定得到效率更高的代码</td></tr><tr><td>-Dname[=definition]</td><td>将名为 name 的宏定义为 definition，如果中括号中的部分缺省，则宏被定义为 1</td></tr><tr><td>-<strong>I</strong>dir</td><td>(大写 I)在编译源程序时增加一个搜索头文件的额外目录——dir，即 include 增加一个搜索的额外目录</td></tr><tr><td>-Ldir</td><td>(大写 L)在编译源文件时增加一个搜索库文件的额外目录——dir</td></tr><tr><td>-llibrary</td><td>(小写 l)在编译链接文件时增加一个额外的库，库名为 library.a</td></tr><tr><td>-E</td><td>指定 GCC 在生成预处理文件后停止</td></tr><tr><td>-S</td><td>指定 GCC 在生成汇编文件后停止</td></tr><tr><td>-w</td><td>禁止所有警告</td></tr><tr><td>-Wwarning</td><td>允许产生 warning 类型的警告，warning 可以是：main、unused 等很多取值，最常用是-Wall，表示产生所有警告。如果 warning 取值为 error，其含义是将所有警告作为错误（error），即出现警告就停止编译。</td></tr></tbody></table><h4 id="一步编译、分步编译"><a href="#一步编译、分步编译" class="headerlink" title="一步编译、分步编译"></a>一步编译、分步编译</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524100017488.png" alt="image-20230524100017488"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524100042597.png" alt="image-20230524100042597"></p><h4 id="不同目录、指定头文件"><a href="#不同目录、指定头文件" class="headerlink" title="不同目录、指定头文件"></a>不同目录、指定头文件</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524100829869.png" alt="image-20230524100829869"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524101038353.png" alt="image-20230524101038353"></p><h3 id="make-工具"><a href="#make-工具" class="headerlink" title="make 工具"></a>make 工具</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>根据 makefile 文件中预定的规则完成对特定文件的编译，最后生成对应的可执行文件</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>判断依赖项是否为最新，否则生成新的目标</p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524101302717.png" alt="image-20230524101302717"></p><h3 id="make-层次图、makefile-文件"><a href="#make-层次图、makefile-文件" class="headerlink" title="make 层次图、makefile 文件"></a>make 层次图、makefile 文件</h3><h4 id="make-层次图"><a href="#make-层次图" class="headerlink" title="make 层次图"></a>make 层次图</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524101831820.png" alt="image-20230524101831820"></p><h4 id="makefile-文件"><a href="#makefile-文件" class="headerlink" title="makefile 文件"></a>makefile 文件</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524101542449.png" alt="image-20230524101542449"></p><h3 id="gdb-调试工具的基本使用"><a href="#gdb-调试工具的基本使用" class="headerlink" title="gdb 调试工具的基本使用"></a>gdb 调试工具的基本使用</h3><table><thead><tr><th>file</th><th><strong>指定需要进行调试的程序</strong></th></tr></thead><tbody><tr><td>step</td><td><strong>单步（行）执行，如果遇到函数会进入函数内部</strong></td></tr><tr><td>next</td><td><strong>单步（行）执行，如果遇到函数不会进入函数内部</strong></td></tr><tr><td>run</td><td><strong>启动被执行的程序</strong></td></tr><tr><td>quit</td><td><strong>退出**<strong>gdb*</strong>*调试环境</strong></td></tr><tr><td>print</td><td><strong>查看变量或者表达式的值</strong></td></tr><tr><td>break</td><td><strong>设置断点，程序执行到断点就会暂停起来</strong></td></tr><tr><td>shell</td><td><strong>执行其后的**<strong>shell*</strong>*命令</strong></td></tr><tr><td>list</td><td><strong>查看指定文件或者函数的源代码，并标出行号</strong></td></tr></tbody></table><h3 id="静态函数库、动态函数库的创建与使用"><a href="#静态函数库、动态函数库的创建与使用" class="headerlink" title="静态函数库、动态函数库的创建与使用"></a>静态函数库、动态函数库的创建与使用</h3><ul><li>静态函数库 名字一般是 libxxx.a</li><li>动态函数库 名字一般是 libxxx.so</li><li>相对于静态函数库，动态函数库在编译的时候并没有被编译进目标代码中，程序执行到相关函数时才调用该函数库里的相应函数，因此动态函数库所产生的可执行文件比较小</li><li>使用 GCC 编译器可以将函数库与自己开发的程序链接起来例如 libc.so 中包含了标准的输入输出函数，当链接程序进行目标代码链接时会自动搜索该程序并将其链接到可执行文件中</li></ul><h4 id="静态函数库的创建与使用"><a href="#静态函数库的创建与使用" class="headerlink" title="静态函数库的创建与使用"></a>静态函数库的创建与使用</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524102735534.png" alt="image-20230524102735534"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524102748878.png" alt="image-20230524102748878"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524102822392.png" alt="image-20230524102822392"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524102835779.png" alt="image-20230524102835779"></p><h4 id="动态函数库的创建与使用"><a href="#动态函数库的创建与使用" class="headerlink" title="动态函数库的创建与使用"></a>动态函数库的创建与使用</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524103518948.png" alt="image-20230524103518948"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524103541573.png" alt="image-20230524103541573"></p><h2 id="第十讲"><a href="#第十讲" class="headerlink" title="第十讲"></a>第十讲</h2><h3 id="磁盘设备的命名方式"><a href="#磁盘设备的命名方式" class="headerlink" title="磁盘设备的命名方式"></a>磁盘设备的命名方式</h3><p>Linux 系统磁盘设备命名方式遵循一定的规则</p><ul><li>前两个字母表示分区所在设备的类型<br>hd：IDE 硬盘<br>sd：SCSI 硬盘（U 盘，移动硬盘等）</li><li>第三个字母表示分区在哪个设备上<br>hda：第一块 IDE 硬盘<br>sda：第一块 SCSI 硬盘<br>sdb：第二块 SCSI 硬盘</li><li>数字表示分区的次序<br>hda1：第一块 IDE 硬盘第一个分区<br>sdb2：第二块 SCSI 硬盘第二个分区</li><li>查看硬盘及分区情况<br>fdisk -l</li></ul><h3 id="Linux-的文件系统、VFS-的功能和作用（含图）"><a href="#Linux-的文件系统、VFS-的功能和作用（含图）" class="headerlink" title="Linux 的文件系统、VFS 的功能和作用（含图）"></a>Linux 的文件系统、VFS 的功能和作用（含图）</h3><h4 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h4><p>FAT、NTFS、ExtFAT、ext2、ext3、xfs、APFS</p><h4 id="Linux-支持哪些文件系统"><a href="#Linux-支持哪些文件系统" class="headerlink" title="Linux 支持哪些文件系统"></a>Linux 支持哪些文件系统</h4><p>输入命令 cat /proc/filesystems 查看</p><h4 id="虚拟文件系统-VFS"><a href="#虚拟文件系统-VFS" class="headerlink" title="虚拟文件系统 VFS"></a>虚拟文件系统 VFS</h4><p>VFS 并不是一个实际的文件系统。只存在于内存，系统启动时建立，系统关闭时消亡</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul><li>记录可用文件系统的类型</li><li>将设备与对应的文件系统联系起来</li><li>处理面向文件的通用操作</li><li>涉及到针对文件系统的操作时，把他们映射到相关的物理文件系统</li></ul><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ul><li>更好的支持多种不同的文件系统，把文件系统从操作系统和系统服务中分离处理来，在它们之间使用了一个接口层，也就是虚拟文件系统 VFS（Virtual File System）</li><li>VFS 是 Linux 内核中的软件层，它在内核中提供了一组标准的、抽象的文件操作，允许不同的文件系统实现共存，并向用户空间程序提供统一的文件系统接口</li><li>通过 VFS 将不同的文件系统的实现细节隐藏起来，从外部看上去，所有的文件系统都是一样的</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524104104803.png" alt="image-20230524104104803"></p><h3 id="设备挂载过程"><a href="#设备挂载过程" class="headerlink" title="设备挂载过程"></a>设备挂载过程</h3><ul><li>查看设备：使用命令 “fdisk -l” 可以查看系统的存储设备</li><li>挂载设备：首先使用 mkdir 命令建立挂载点目录，然后再使用 mount 命令挂载相关设备</li><li>访问设备</li><li>卸载设备：用户在使用完挂载设备后，不能直接将挂载设备从系统拔出，否则会出现问题，严重的会导致系统崩溃。系统必须先执行卸载命令然后再把该设备拔出</li></ul><h3 id="mkfs、fdisk、mount、umount、df、du、whoami、who、w、jobs、bg、fg、-amp-（后台进程启动）"><a href="#mkfs、fdisk、mount、umount、df、du、whoami、who、w、jobs、bg、fg、-amp-（后台进程启动）" class="headerlink" title="mkfs、fdisk、mount、umount、df、du、whoami、who、w、jobs、bg、fg、&amp;（后台进程启动）"></a>mkfs、fdisk、mount、umount、df、du、whoami、who、w、jobs、bg、fg、&amp;（后台进程启动）</h3><h4 id="mkfs"><a href="#mkfs" class="headerlink" title="mkfs"></a>mkfs</h4><p>作用：把指定的设备格式为指定的文件系统</p><p>格式：mkfs [选项][-t &lt;文件系统类型&gt;] [设备名称] [区块数]</p><p>例子# mkfs –t ext3 /dev/hda4</p><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>作用：创建和维护分区表</p><p>格式：fdisk [必要参数][选择参数]</p><table><thead><tr><th>-l</th><th>列出素所有分区表</th></tr></thead><tbody><tr><td>-u</td><td>与-l 配合使用，显示分区数目</td></tr></tbody></table><p>例子</p><ul><li># fdisk -l</li><li># fdisk -lu</li></ul><h4 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h4><p>作用：挂载 Linux 系统外的文件</p><p>格式：mount [选项] &lt;挂载设备名称&gt; &lt;挂载点&gt;</p><table><thead><tr><th>-t</th><th>指定文件系统类型，通常不必指定。mount 会自动选择正确的类型</th></tr></thead><tbody><tr><td>-o auto、-o noauto</td><td>打开/关闭自动挂上模式</td></tr><tr><td>-o defaults</td><td>使用预设的选项 rw, suid, dev, exec, auto, nouser, and async</td></tr><tr><td>-o ro</td><td>用只读模式挂上</td></tr><tr><td>-o rw</td><td>用可读写模式挂上</td></tr></tbody></table><p>例子：</p><ul><li># mount -t ext2 /dev/fd0 /mnt/floppy</li><li># mount -o iocharset=cp936 /dev/sda1 /mnt/usb</li><li># mount -o ro /dev/hda1 /mnt</li></ul><h4 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h4><p>作用：卸除文件系统</p><p>格式：umount [选项] 挂载点或设备名</p><table><thead><tr><th>-a</th><th>卸除/etc/mtab 中记录的所有文件系统</th></tr></thead><tbody><tr><td>-n</td><td>卸除时不要将信息存入/etc/mtab 文件中</td></tr><tr><td>-r</td><td>若无法成功卸除，则尝试以只读的方式重新挂入文件系统</td></tr><tr><td>-t &lt;文件系统类型&gt;</td><td>仅卸除选项中所指定的文件系统</td></tr><tr><td>-v</td><td>执行时显示详细的信息</td></tr></tbody></table><p>例子</p><ul><li># umount /mnt/cd</li><li># umount -v /dev/sda1</li></ul><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p>作用：查看磁盘空间使用情况</p><p>格式：df [选项] [路径]</p><table><thead><tr><th>-a</th><th>–all 包含所有的具有 0 Blocks 的文件系统</th></tr></thead><tbody><tr><td>-h</td><td>–human-readable 使用人类可读的格式</td></tr><tr><td>-i</td><td>–inodes 列出 inode 资讯，不列出已使用 block</td></tr><tr><td>-l</td><td>–local 限制列出的文件结构</td></tr><tr><td>-t</td><td>–type=TYPE 限制列出文件系统的 TYPE</td></tr><tr><td>-T</td><td>–print-type 显示文件系统的形式</td></tr></tbody></table><p>例子</p><ul><li># df</li><li># df -ahT</li></ul><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p>作用：统计目录或文件所占磁盘空间大小</p><p>格式：du [选项/参数] [目录名…]</p><table><thead><tr><th>-a</th><th>递归显示制定目录中各个文件及下级目录中各文件占用的数据块数</th></tr></thead><tbody><tr><td>-h</td><td>以友好直观方式显示信息，即以 KB 或 MB 为单位</td></tr><tr><td>-b</td><td>以字节为单位列出磁盘空间使用情况</td></tr><tr><td>-m</td><td>以 MB 为单位显示</td></tr><tr><td>-s</td><td>对每个目录参数只给出占用的数据块总数</td></tr></tbody></table><p>例子 du -m /tmp</p><h4 id="whoami-who-w"><a href="#whoami-who-w" class="headerlink" title="whoami/who/w"></a>whoami/who/w</h4><p>whoami 查看当前登录用户名称</p><p>id 查看当前登录用户信息[-u] 只显示 UID[-g] 只显示 GID</p><p>who 查看当前登录用户列表[-H] 显示标题[-l] 显示来源</p><p>w 查看当前登录用户情况，who 的增强版</p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524110919905.png" alt="image-20230524110919905"></p><h4 id="jobs、bg、fg、-amp"><a href="#jobs、bg、fg、-amp" class="headerlink" title="jobs、bg、fg、&amp;"></a>jobs、bg、fg、&amp;</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524111235420.png" alt="image-20230524111235420"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524111328669.png" alt="image-20230524111328669"></p><h3 id="进程的概念、进程和程序的区别与联系"><a href="#进程的概念、进程和程序的区别与联系" class="headerlink" title="进程的概念、进程和程序的区别与联系"></a>进程的概念、进程和程序的区别与联系</h3><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h4><ul><li>Linux 系统上所有运行的东西都可以称之为一个进程，如每个用户任务、每个系统管理任务</li><li>进程是一个程序的运行</li></ul><p>Linux 操作系统包括三种不同类型的进程</p><ul><li>交互进程：由 shell 启动的进程</li><li>批处理进程：这种进程和终端没有联系，是一个进程序列</li><li>守护进程：在后台持续运行的进程</li></ul><h4 id="进程和程序的区别与联系"><a href="#进程和程序的区别与联系" class="headerlink" title="进程和程序的区别与联系"></a>进程和程序的区别与联系</h4><ul><li>程序只是一个静态的指令集合，不占系统的运行资源，只占用磁盘空间</li><li>进程是一个随时都可能发生变化的、动态的、使用系统运行资源（cpu，内存等）的程序</li><li>一个程序可以启动多个进程</li></ul><h3 id="at-和-crontab-的区别与联系、各自的创建、删除、查看"><a href="#at-和-crontab-的区别与联系、各自的创建、删除、查看" class="headerlink" title="at 和 crontab 的区别与联系、各自的创建、删除、查看"></a>at 和 crontab 的区别与联系、各自的创建、删除、查看</h3><h4 id="at-和-crontab-的区别与联系"><a href="#at-和-crontab-的区别与联系" class="headerlink" title="at 和 crontab 的区别与联系"></a>at 和 crontab 的区别与联系</h4><ul><li>at 命令产生的进程调度不具有周期性，只能在时间条件满足时执行一次（不具有周期性）</li><li>crontab 让使用者在固定时间或固定时间间隔执行程序（重复周期性）</li></ul><h4 id="at"><a href="#at" class="headerlink" title="at"></a>at</h4><p>作用：指定在将来的某个时间点执行某些命令</p><p>用法： at [选项] [时间]</p><table><thead><tr><th>-m</th><th>当 at 工作完成后，无论命令是否输出，都用 E-mail 通知执行 at 命令的用户。</th></tr></thead><tbody><tr><td>-c 工作标识号</td><td>显示该 at 工作的实际内容。</td></tr><tr><td>-t 时间</td><td>在指定时间提交工作并执行，时间格式为 [[CC]YY]MMDDhhmm。</td></tr><tr><td>-d</td><td>删除某个工作，需要提供相应的工作标识号（ID），同 atrm 命令的作用相同。</td></tr><tr><td>-l</td><td>列出当前所有等待运行的工作，和 atq 命令具有相同的额作用。</td></tr><tr><td>-f 脚本文件</td><td>指定所要提交的脚本文件。</td></tr></tbody></table><table><thead><tr><th>HH:MM</th><th>比如 04:00 AM。如果时间已过，则它会在第二天的同一时间执行</th></tr></thead><tbody><tr><td>Midnight(midnight)</td><td>代表 12:00 AM（也就是 00:00）</td></tr><tr><td>Noon(noon)</td><td>代表 12:00 PM（相当于 12:00）</td></tr><tr><td>Teatime(teatime)</td><td>代表 4:00 PM（相当于 16:00）</td></tr><tr><td>英文月名 日期 年份</td><td>比如 January 15 2018 表示 2018 年 1 月 15 号，年份可有可无</td></tr><tr><td>MMDDYY、MM/DD/YY、MM.DD.YY</td><td>比如 011518 表示 2018 年 1 月 15 号</td></tr><tr><td>now+时间</td><td>以 minutes、hours、days 或 weeks 为单位，例如 now+5 days 表示命令在 5 天之后的此时此刻执行</td></tr></tbody></table><h5 id="交互式"><a href="#交互式" class="headerlink" title="交互式"></a>交互式</h5><p>在 shell 提示符下输入”at 时间”，然后按回车键。这时在下一行 shell 会等待用户继续输入要执行的命令。每一行输入一个命令，所有命令都输入完毕后按 Ctrl+d 键结束</p><h5 id="指定文件"><a href="#指定文件" class="headerlink" title="指定文件"></a>指定文件</h5><p>将各个命令写入 shell 脚本中，然后使用下面格式设置在指定时间执行 shell 脚本中的命令</p><p>at 时间 -f 脚本文件</p><p>例子</p><ul><li>at -l | atq 任务号</li><li>at -d | atrm 任务号</li><li>at -c 任务号</li></ul><h4 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h4><ul><li><p>at 命令产生的进程调度不具有周期性，只能在时间条件满足时执行一次</p></li><li><p>但很多时候需要重复地周期性地执行某个程序</p></li><li><p>crontab 用来让使用者在固定时间或固定时间间隔执行程序</p></li><li><p>cron 命令在系统启动时由一个 shell 脚本自动启动，进入后台，crond 守护进程(/etc/init.d/crond)</p></li><li><p>cron 启动后搜索/var/spool/cron 目录，寻找以/etc/passwd 文件中的用户名命名的 crontab 文件，被找到的这种文件将载入内存</p></li><li><p>如果没有 crontab 文件，就转入“休眠”状态，释放系统资源</p></li><li><p>cron 每分钟“醒”过来一次，查看当前是否有需要运行的命令</p></li><li><p>如果发现某个用户设置了 crontab 文件，它将以该用户的身份去运行文件中指定的命令。命令执行结束后，任何输出都将作为邮件发送给 crontab 的所有者，或者/etc/crontab 文件中 MAILTO 环境变量中指定的用户。</p></li><li><p>对用户来说，只需要关注自己的 crontab 文件的撰写，不需干涉 crond 进程的执行</p></li><li><p>因为一个用户只有一个 crontab 文件，所以，crontab 文件不能直接创建或者直接修改(root 可以)，必须通过 crontab 命令得到</p></li><li><p>crontab 命令用于安装、删除或者列出用于驱动 cron 后台进程的 crontab 文件</p></li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524120928953.png" alt="image-20230524120928953"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524121029254.png" alt="image-20230524121029254"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524121115822.png" alt="image-20230524121115822"></p><p>每隔 1 分钟打印当前时间</p><p>*/1 0-23/1 * * * date</p><h3 id="ps、kill、free"><a href="#ps、kill、free" class="headerlink" title="ps、kill、free"></a>ps、kill、free</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>作用:显示当前进程的状态</p><p>格式：ps [选项]</p><table><thead><tr><th>-A</th><th>列出所有的进程</th></tr></thead><tbody><tr><td>-w</td><td>显示加宽可以显示较多的资讯</td></tr><tr><td>-au</td><td>显示较详细的资讯</td></tr><tr><td>-aux</td><td>显示所有包含其他使用者的行程</td></tr><tr><td>-e</td><td>显示所有进程</td></tr><tr><td>-f</td><td>采用全格式显示</td></tr></tbody></table><p>例子</p><ul><li># ps -ef | grep sshd</li><li># ps -aux | grep vsftpd</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524121641123.png" alt="image-20230524121641123"></p><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><p>作用:删除执行中的程序或工作</p><p>格式： kill [-s &lt;信息名称或编号&gt;][程序] kill [-l &lt;信息编号&gt;]</p><table><thead><tr><th>1 (HUP)</th><th>重新加载进程</th></tr></thead><tbody><tr><td>9 (KILL)</td><td>杀死一个进程</td></tr><tr><td>15 (TERM)</td><td>正常停止一个进程</td></tr></tbody></table><p>例子</p><ul><li># kill -9 pid</li><li># kill -HUP pid</li><li># kill -l</li></ul><blockquote><p>解除系统死锁，内存回收</p><p>Linux 的 kill 命令是向进程发送信号，kill 不是杀死的意思，-9 表示无条件退出，但由进程自行决定是否退出，这就是为什么 kill -9 终止不了系统进程和守护进程的原因</p><p>killall 命令</p><p># killall -KILL atd #按进程名</p></blockquote><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>作用：显示内存状态，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等</p><p>格式：free [选项]</p><table><thead><tr><th>-b</th><th>以 Byte 为单位显示内存使用情况</th></tr></thead><tbody><tr><td>-k</td><td>以 KB 为单位显示内存使用情况</td></tr><tr><td>-m</td><td>以 MB 为单位显示内存使用情况</td></tr><tr><td>-h</td><td>以合适的单位显示内存使用情况，最大为三位数</td></tr><tr><td>-o</td><td>不显示缓冲区调节列</td></tr><tr><td>-s&lt;间隔描述&gt;</td><td>持续观察内存使用状况</td></tr><tr><td>-t</td><td>显示内存总和列</td></tr></tbody></table><p>例子 # free -mt</p><h3 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h3><ul><li>日志文件（log files）是包含关于系统消息的文件，包括内核、服务、在系统上运行的应用程序等</li><li>多数的日志文件位于/var/log 目录下，不同的日志文件记载不同的信息</li><li>某些程序（如 apache）在/var/log 中有单独的日志文件目录</li><li>多数日志文件都是用纯文本格式，可以使用任何文本编辑器如 vi 查看它们</li><li>大多数日志文件都需要拥有特权才允许查看</li></ul><h2 id="第十一讲"><a href="#第十一讲" class="headerlink" title="第十一讲"></a>第十一讲</h2><h3 id="Docker-与虚拟机的区别"><a href="#Docker-与虚拟机的区别" class="headerlink" title="Docker 与虚拟机的区别"></a>Docker 与虚拟机的区别</h3><p>Docker 是一个应用打包、分发、部署的工具。</p><p>Docker：可理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要。</p><p>普通虚拟机：一个完整而庞大的系统，包含各种不管你要不要的软件。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>普通虚拟机</strong></th><th><strong>Docker</strong></th></tr></thead><tbody><tr><td>跨平台</td><td>通常只能在桌面级系统运行，例如 Windows/Mac，无法在不带图形界面的服务器上运行</td><td>支持的系统非常多，各类 Windows 和 Linux 都支持</td></tr><tr><td>性能</td><td>性能损耗大，内存占用高，因为是把整个完整系统都虚拟出来了</td><td>性能好，只虚拟软件所需运行环境，最大化减少没用的配置</td></tr><tr><td>自动化</td><td>需要手动安装所有东西</td><td>一个命令就可以自动部署好所需环境</td></tr><tr><td>一致性</td><td>环境一致性不高，不同系统差异大</td><td>一致性好，不同系统都一样部署方式</td></tr></tbody></table><h3 id="Docker-的优势"><a href="#Docker-的优势" class="headerlink" title="Docker 的优势"></a>Docker 的优势</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123222121.png" alt="image-20230524123222121"></p><h3 id="docker-search-pull-images-run-start-stop-restart-ps-rm-attach-exec-commit-build-tag-push"><a href="#docker-search-pull-images-run-start-stop-restart-ps-rm-attach-exec-commit-build-tag-push" class="headerlink" title="docker search, pull, images, run, start, stop, restart, ps, rm, attach, exec, commit, build, tag, push"></a>docker search, pull, images, run, start, stop, restart, ps, rm, attach, exec, commit, build, tag, push</h3><h4 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123336236.png" alt="image-20230524123336236"></p><h4 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123408198.png" alt="image-20230524123408198"></p><h4 id="images"><a href="#images" class="headerlink" title="images"></a>images</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123450342.png" alt="image-20230524123450342"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123606248.png" alt="image-20230524123606248"></p><h4 id="run-start"><a href="#run-start" class="headerlink" title="run,start"></a>run,start</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123657006.png" alt="image-20230524123657006"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123803620.png" alt="image-20230524123803620"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524123909818.png" alt="image-20230524123909818"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124010881.png" alt="image-20230524124010881"></p><h4 id="ps-stop-restart"><a href="#ps-stop-restart" class="headerlink" title="ps,stop,restart"></a>ps,stop,restart</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124225263.png" alt="image-20230524124225263"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124243556.png" alt="image-20230524124243556"></p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124346500.png" alt="image-20230524124346500"></p><h4 id="attach-exec"><a href="#attach-exec" class="headerlink" title="attach,exec"></a>attach,exec</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124452193.png" alt="image-20230524124452193"></p><h4 id="commit-build"><a href="#commit-build" class="headerlink" title="commit,build"></a>commit,build</h4><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124623789.png" alt="image-20230524124623789"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124714327.png" alt="image-20230524124714327"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524124757327.png" alt="image-20230524124757327"></p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524141658951.png" alt="image-20230524141658951"></p><table><thead><tr><th>FROM [镜像]</th><th>指定新镜像所基于的镜像，第一条指令必须为 FROM 指令，每创建一个镜像就需要一条 FROM 指令，例如 centos:7。from 有两层含义：① 开启一个新的镜像 ② 必须写的一行指令</th></tr></thead><tbody><tr><td>MAINTAINER [名字]</td><td>说明新镜像的维护人信息（可写可不写）</td></tr><tr><td>RUN 命令</td><td>每一条 RUN 后面跟一条命令，在所基于的镜像上执行命令，并提交到新的镜像中，RUN 必须大写</td></tr><tr><td>CMD [“要运行的程序”，“参数 1”、“参数 2”]</td><td>指定启动容器时需要运行的命令或者脚本，Dockerfile 只能有一条 CMD 命令，如果指定多条则只能执行最后一条，“bin/bash”也是一条 CMD,并且会<strong>覆盖</strong>image 镜像里面的 cmd。</td></tr><tr><td>EXPOSE [端口号]</td><td>指定新镜像加载到 Docker 时要开启的端口暴露端口，就是这个容器暴露出去的端口号。</td></tr><tr><td>ENV [环境变量] [变量值]</td><td>设置一个环境变量的值，会被后面的 RUN 使用。容器可以根据自己的需求创建时传入环境变量，镜像不可以。</td></tr><tr><td>ADD [源文件/目录] [目标文件/目录]</td><td>① 将源文件复制到目标文件，源文件要与 Dockerfile 位于相同目录中，② 或者是一个 URL，③ 若源文件是压缩包则会将其解压缩。</td></tr><tr><td>COPY [源文件/目录] [目标文件/目录]</td><td>将本地主机上的文件/目录复制到目标地点，源文件/目录要与 Dockerfile 在相同的目录中，copy 只能用于复制，add 复制的同时，如果复制的对象是压缩包，ADD 还可以解压，copy 比 add 节省资源。</td></tr><tr><td><strong>VOLUME [“**<strong>目录*</strong>*”]</strong></td><td>在容器中创建一个挂载点，简单来说就是-v，指定镜像的目录挂载到宿主机上（<strong>由容器创建和管理</strong>）。</td></tr><tr><td>USER [用户名/UID]</td><td>指定运行容器时的用户</td></tr><tr><td>WORKDIR [路径]</td><td>为后续的 RUN、CMD、ENTRYPOINT 指定工作目录，相当于是一个临时的“cd”，否则需要使用绝对路径，例如 workdir /opt。移动到 opt 目录，并在这下面的指令都是在 opt 下执行。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524142247004.png" alt="image-20230524142247004"></p><h2 id="第十二讲"><a href="#第十二讲" class="headerlink" title="第十二讲"></a>第十二讲</h2><h3 id="X-Window-的作用和组成（含图）、每个组成部分的作用"><a href="#X-Window-的作用和组成（含图）、每个组成部分的作用" class="headerlink" title="X Window 的作用和组成（含图）、每个组成部分的作用"></a>X Window 的作用和组成（含图）、每个组成部分的作用</h3><h4 id="X-Window"><a href="#X-Window" class="headerlink" title="X Window"></a>X Window</h4><blockquote><p>一种以位图方式显示的软件窗口系统</p><p>诞生于 1984，比 Microsoft Windows 要早</p><p>是一套独立于内核的软件</p><p>X Window 系统由三个基本元素组成</p><p>X 服务端</p><p>X 客户端</p><p>X 通信通道</p></blockquote><ul><li>X Server</li><li>X Client</li><li>Xlib</li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524142918786.png" alt="image-20230524142918786"></p><h4 id="X-Server-X-服务端"><a href="#X-Server-X-服务端" class="headerlink" title="X Server (X 服务端)"></a>X Server (X 服务端)</h4><blockquote><p>是控制输入及输出设备并维护相关资源的程序，它接收输入设备的信息，并将其传给 X Client，而将 X Client 传来的信息输出到屏幕上(在屏幕上构造方块(窗口)，然后画出里面的元素)</p><p>每一套显示设备只对应唯一的 X Server</p><p>由系统供应商提供，通常无法被用户修改</p><p>只是一个普通的用户程序</p></blockquote><h4 id="X-Client-X-客户端"><a href="#X-Client-X-客户端" class="headerlink" title="X Client(X 客户端)"></a>X Client(X 客户端)</h4><blockquote><p>是应用程序的核心部分，它与硬件无关，每个应用程序就是一个 X Client</p><p>X Client 可以是终端仿真器(Xterm)或图形界面程序，它不直接对显示器绘制或者操作图形，而是与 X Server 通信，由 X Server 控制显示</p><p>X Client 无法直接影响视窗行为或显示效果，它们只能发送一个请求给 X Server，由 X Server 来完成这些的请求</p><p>多种多样的 X Client 程序向 X Server 发出请求，由 X Server 运算得出结果，再显示到指定的地方去</p></blockquote><h4 id="X-通信通道"><a href="#X-通信通道" class="headerlink" title="X 通信通道"></a>X 通信通道</h4><blockquote><p>X 通信通道的主体是 xlib（X 函数库）</p><p>X Client 调用 xlib，利用相应的通信功能向 X Server 发出请求</p><p>X Server 完成任务之后，同样调用 xlib 把结果显示指点的设备上去</p></blockquote><h4 id="X-Window-的特点"><a href="#X-Window-的特点" class="headerlink" title="X Window 的特点"></a>X Window 的特点</h4><ul><li><p>良好的网络支持</p><p>X Window 采用了 C/S 网络结构，X Client 和 X Server 可以通过网络来通信，而且有良好的网络透明性</p></li><li><p>个性化的窗口界面</p><p>X Window 并未对窗口界面作统一的规范，程序员可以根据需求自行设计，其中最有名的就是后面将要介绍的 GNOME 与 KDE</p></li><li><p>不内嵌于操作系统</p><p>X Window 只定义了一个标准，而不属于某个操作系统，因此可在不同的操作系统上运行相同的 X Window 软件</p></li></ul><h3 id="修改系统运行级别（含运行级别-0-3-5-6）"><a href="#修改系统运行级别（含运行级别-0-3-5-6）" class="headerlink" title="修改系统运行级别（含运行级别 0 3 5 6）"></a>修改系统运行级别（含运行级别 0 3 5 6）</h3><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524143809829.png" alt="image-20230524143809829"></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230524143854798.png" alt="image-20230524143854798"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>1、2</p><p>4、5、6、7</p><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><ul><li>选择题 20 题，每题 1 分，20 分</li><li>简答题 6 题，每题 5 分，30 分</li><li>编码题 3 题，6*1 + 7*2 分，20 分</li><li>综合应用题 3 题，每题 10 分，30 分</li></ul><h2 id="易错"><a href="#易错" class="headerlink" title="易错"></a>易错</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2023/01/11/test/"/>
      <url>/2023/01/11/test/</url>
      
        <content type="html"><![CDATA[<blockquote><p>test</p></blockquote><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111124441672.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器原理</title>
      <link href="/2022/07/25/liu-lan-qi-yuan-li/"/>
      <url>/2022/07/25/liu-lan-qi-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20220725155032529.png" alt="浏览器渲染过程"></p><h2 id="JavaScript引擎"><a href="#JavaScript引擎" class="headerlink" title="JavaScript引擎"></a>JavaScript引擎</h2><h3 id="为什么需要JavaScript引擎呢？"><a href="#为什么需要JavaScript引擎呢？" class="headerlink" title="为什么需要JavaScript引擎呢？"></a>为什么需要JavaScript引擎呢？</h3><ul><li>高级的编程语言都是需要转成最终的机器指令来执行的；</li><li>事实上我们编写的JavaScript无论你交给浏览器或者Node执行，最后都是需要被CPU执行的；</li><li>但是CPU只认识自己的指令集，实际上是机器语言，才能被CPU所执行；</li><li>需要JavaScript引擎帮助我们将JavaScript代码翻译成CPU指令来执行；</li></ul><h4 id="比较常见的JavaScript引擎有哪些呢？"><a href="#比较常见的JavaScript引擎有哪些呢？" class="headerlink" title="比较常见的JavaScript引擎有哪些呢？"></a>比较常见的JavaScript引擎有哪些呢？</h4><ul><li>JavaScriptCore：WebKit中的JavaScript引擎，Apple公司开发；</li><li>V8：Google开发的强大JavaScript引擎，也帮助Chrome从众多浏览器中脱颖而出；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue笔记（一）</title>
      <link href="/2022/07/24/vue-bi-ji-yi/"/>
      <url>/2022/07/24/vue-bi-ji-yi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>小程序学习</title>
      <link href="/2022/07/22/xiao-cheng-xu-shi-zhan-xiang-mu-zhan-wang/"/>
      <url>/2022/07/22/xiao-cheng-xu-shi-zhan-xiang-mu-zhan-wang/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是小程序"><a href="#什么是小程序" class="headerlink" title="什么是小程序"></a>什么是小程序</h2><ul><li><p>程序（Mini Program）是一种不需要下载安装即可使用的应用，它实现了“触手可及”的梦想，使用起来方<br>便快捷，用完即走。</p></li><li><p>事实上，目前小程序在我们生活中已经随处可见（特别是这次疫情的推动，不管是什么岗位、什么年龄阶段的<br>人，都哪都需要打开健康码）；</p></li><li><p>最初我们提到小程序时，往往指的是 微信小程序：但是目前小程序技术本身已经被各个平台所实现和支持；</p></li><li><p> 那么目前常见的小程序有哪些呢？</p></li></ul><p>  微信小程序、支付宝小程序、淘宝小程序、抖音小程序、头条小程序、QQ小程序、美团小程序等等；</p><h2 id="小程序的定位"><a href="#小程序的定位" class="headerlink" title="小程序的定位"></a>小程序的定位</h2><p>介于原生App和手机H5页面之间的一个产品定位。</p><p>由谁开发事实上是由它的技术特点所决定的，比如微信小程序WXML、WXSS、JavaScript；它更接近于我们前端的开发技术栈，所以小程序是由前端来开发的；</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li><p>原生小程序开发：<br>微信小程序：<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/">https://developers.weixin.qq.com/miniprogram/dev/framework/</a><br>主要技术包括：WXML、WXSS、JavaScript；</p></li><li><p>选择框架开发小程序：</p><p>uniapp和taro：</p><ul><li>uni-app：<br>由DCloud团队开发和维护；<br>uni-app 是一个使用 Vue 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/飞书/QQ/快手/钉钉/淘宝）、快应用等多个平台。<br>uni-app目前是很多公司的技术选型，特别是希望适配移动端App的公司；</li><li>taro：<br>由京东团队开发和维护；<br>taro 是一个开放式 跨端 跨框架 解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ / 飞书 小程序 / H5 /<br>RN 等应用；<br>taro因为本身支持React、Vue的选择，给了我们更加灵活的选择空间；<br>特别是在Taro3.x之后，支持Vue3、React Hook写法等；<br>taro[‘tɑ:roʊ]，泰罗·奥特曼，宇宙警备队总教官，实力最强的奥特曼；</li><li>uni-app和taro开发原生App：<br>无论是适配原生小程序还是原生App，都有较多的适配问题，所以你还是需要多了解原生的一些开发知识；<br>产品使用体验整体相较于原生App差很多；<br>也有其他的技术选项来开发原生App：ReactNative、Flutter；</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20220722101223361.png" alt="小程序核心技术"></p><h2 id="小程序项目结构"><a href="#小程序项目结构" class="headerlink" title="小程序项目结构"></a>小程序项目结构</h2><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20220722102910323.png" alt="小程序项目结构"></p><h2 id="一些编写过程中的笔记"><a href="#一些编写过程中的笔记" class="headerlink" title="一些编写过程中的笔记"></a>一些编写过程中的笔记</h2><ul><li>image组件默认宽度是320px，高度是240px，如果想要根据宽度按照比例计算出高度可以给组件增加mode属性，即mode=“widthFix”</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 实战 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript应用</title>
      <link href="/2022/07/21/javascript-ying-yong/"/>
      <url>/2022/07/21/javascript-ying-yong/</url>
      
        <content type="html"><![CDATA[<p>​        前端行业在近几年快速发展，并且开发模式、框架越来越丰富。但是不管你学习的是Vue、React、Angular，包括之前的jQuery，以及后续新出的框架 — 他们本身都是基于JavaScript的，使用他们的过程中你都必须好好掌握JavaScript。所以<strong>JavaScript是我们前端万丈高楼的根基，无论是前端发展的万丈高楼，还是我们筑建自己的万丈高楼。</strong></p><p>​        Stack Overflow的创立者之一的 Jeff Atwood 在2007年提出了著名的 <strong>Atwood定律</strong>：</p><p>​        <em>Any application that can be written in JavaScript, will eventually be written in JavaScript.</em><br>​        任何可以使用JavaScript来实现的应用都最终都会使用JavaScript实现。</p><h2 id="JavaScript应用越来越广泛"><a href="#JavaScript应用越来越广泛" class="headerlink" title="JavaScript应用越来越广泛"></a>JavaScript应用越来越广泛</h2><p><strong>Web开发：</strong> 原生JavaScript、react开发、vue开发、Angular开发</p><p><strong>移动端开发：</strong>ReactNative、Weex</p><p><strong>小程序端开发：</strong>微信小程序、支付宝小程序、uniapp、taro</p><p><strong>桌面应用开发：</strong>Electron，比如VSCode<br><strong>后端开发：</strong>Node环境，比如express、koa、egg.js</p><h2 id="JavaScript有许多让人难以掌握的知识点"><a href="#JavaScript有许多让人难以掌握的知识点" class="headerlink" title="JavaScript有许多让人难以掌握的知识点"></a>JavaScript有许多让人难以掌握的知识点</h2><p><strong>面向对象：</strong>JavaScript面向对象、继承、原型、原型链等</p><p><strong>ES新特性：</strong>ES6、7、8、9、10、11、12新特性</p><p><strong>函数、闭包：</strong>闭包的访问规则、闭包的内存泄露、函数中this的指向</p><p><strong>作用域：</strong>作用域的理解、作用域提升、块级作用域、作用域链、AO、GO、VO等概念</p><p><strong>其他：</strong>事件循环、微任务、宏任务、内存管理、Promise、await、asnyc、防抖、节流等等</p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20220721214732100.png" alt="Atwood定律"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法回顾</title>
      <link href="/2022/06/29/suan-fa-hui-gu/"/>
      <url>/2022/06/29/suan-fa-hui-gu/</url>
      
        <content type="html"><![CDATA[<h1 id="前言-太久没有刷Leetcode以及接触算法了，打算利用这个暑假学习其他新东西的同时重新把以前算法捡起来，并且学习巩固算法知识！"><a href="#前言-太久没有刷Leetcode以及接触算法了，打算利用这个暑假学习其他新东西的同时重新把以前算法捡起来，并且学习巩固算法知识！" class="headerlink" title="前言: 太久没有刷Leetcode以及接触算法了，打算利用这个暑假学习其他新东西的同时重新把以前算法捡起来，并且学习巩固算法知识！"></a>前言: 太久没有刷Leetcode以及接触算法了，打算利用这个暑假学习其他新东西的同时重新把以前算法捡起来，并且学习巩固算法知识！</h1><hr><h2 id="什么是最优解？"><a href="#什么是最优解？" class="headerlink" title="什么是最优解？"></a>什么是最优解？</h2><p>一般情况下，认为解决一个问题的算法流程，在<strong>时间复杂度</strong>的指标上，一定要尽可能的低，<strong>先满足了时间复杂度最低这个指标之后，使用最少的空间的算法流程，叫这个问题的最优解。</strong>一般说起最优解都是<strong>忽略掉常数项</strong>这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。</p><hr><h2 id="评估算法优劣的核心指标"><a href="#评估算法优劣的核心指标" class="headerlink" title="评估算法优劣的核心指标"></a>评估算法优劣的核心指标</h2><ul><li>算法时间复杂度 （由流程决定）</li><li>额外的空间复杂度（由流程决定）</li><li>常数项时间（实现细节决定，较时间空间而言没有那么重要)</li></ul><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>确定算法流程的总操作数量与样本数量之间的表达式关系，只看表达式最高阶项的部分，即为时间复杂度。</p><p><strong>如何确定算法流程的总操作数量与样本数量之间的表达式关系？</strong></p><ol><li>想象该算法流程所处理的数据状况，要按照最差情况来。</li><li>把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作。</li><li>如果数据量为N，看看基本动作的数量和N是什么关系。</li></ol><p>当完成了表达式的建立，只要把最高阶项留下即可。低阶项都去掉，高阶项的系数也去掉。</p><p>记为：<strong>O(忽略掉系数的高阶项)</strong></p><p><strong>以插入排序为例子：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​    <strong>想让arr[0~0]上有序，</strong>这个范围只有一个数，当然是有序的。<strong>想让arr[0~1]上有序，</strong>所以从arr[1]开始往前看，如果arr[1]&lt;arr[0]，就交换。否则什么也不做。…<strong>想让arr[0~i]上有序，所以从arr[i]开始往前看，arr[i]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。</strong>最后一步，想让arr[0~N-1]上有序， arr[N-1]这个数不停向左移动，一直移动到左边的数字不再比自己大，停止移动。估算时发现这个算法流程的复杂程度，会因为数据状况的不同而不同。</p><p>​    如果某个算法流程的复杂程度会根据数据状况的不同而不同，那么你必须要按照最差情况来估计。很明显，在最差情况下，如果arr长度为N，插入排序的每一步常数操作的数量，还是如等差数列一般所以，总的常数操作数量 = a*(N^2) + b*N + c (a、b、c都是常数)所以插入排序排序的时间复杂度为O(N^2)。</p><p>​    一定要确保在拆分算法流程时，<strong>拆分出来的所有行为都是常数时间的操作。</strong>这意味着你写算法时，对自己的用过的每一个系统api，都非常的熟悉。否则会影响你对时间复杂度的估算。</p><h4 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h4><p>​    当我们要处理的样本量很大很大时，我们会发现低阶项是什么不是最重要的；每一项的系数是什么，不是最重要的。真正重要的就是最高阶项是什么。这就是时间复杂度的意义，<strong>它是衡量算法流程的复杂程度的一种指标，该指标只与数据量有关，与过程之外的优化无关。</strong></p><hr><h3 id="额外的空间复杂度"><a href="#额外的空间复杂度" class="headerlink" title="额外的空间复杂度"></a>额外的空间复杂度</h3><p>​    在实现算法流程的过程中，需要开辟一些空间来支持算法流程。<strong>作为输入参数的空间，不算额外空间。作为输出结果的空间，也不算额外空间。</strong>因为这些都是必要的、和现实目标有关的。所以都不算。但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部分空间就是额外空间。如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)。</p><hr><h3 id="常数项时间"><a href="#常数项时间" class="headerlink" title="常数项时间"></a>常数项时间</h3><p>​    时间复杂度这个指标，是忽略低阶项和所有常数系数的。</p><p>​    同样时间复杂度的流程，在实际运行时候就一样的好吗？</p><p>​    当然不是。时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的算法，你还要去在时间上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。</p><p>​    比如，位运算的常数时间原小于算术运算的常数时间，这两个运算的常数时间又远小于数组寻址的时间。</p><hr><h3 id="常见的时间复杂度优劣"><a href="#常见的时间复杂度优劣" class="headerlink" title="常见的时间复杂度优劣"></a>常见的时间复杂度优劣</h3><p><strong>排名从好到差：</strong></p><p>O(1)   </p><p>O(logN)   </p><p>O(N)   </p><p>O(N*logN)   </p><p>O(N^2)   </p><p>O(N^3)   </p><p>…   </p><p>O(N^K)</p><p>O(2^N)   </p><p>O(3^N)  </p><p> …   </p><p>O(K^N)</p><p>O(N!)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码提交规范--Angular</title>
      <link href="/2022/05/18/dai-ma-ti-jiao-gui-fan-angular/"/>
      <url>/2022/05/18/dai-ma-ti-jiao-gui-fan-angular/</url>
      
        <content type="html"><![CDATA[<h3 id="git-commit规范-—-Angular提交规范"><a href="#git-commit规范-—-Angular提交规范" class="headerlink" title="git commit规范 — Angular提交规范"></a>git commit规范 — Angular提交规范</h3><h4 id="代码提交风格"><a href="#代码提交风格" class="headerlink" title="代码提交风格"></a>代码提交风格</h4><p>通常我们的git commit会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw17gaqjj30to0cj3zp.jpg"></p><p>但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen</p><ul><li>Commitizen 是一个帮助我们编写规范 commit message 的工具；</li></ul><h4 id="全局配置Commitizen"><a href="#全局配置Commitizen" class="headerlink" title="全局配置Commitizen"></a>全局配置Commitizen</h4><p>全局配置安装Commitizen并在任意目录使用 git cz 指令，查阅官方文档如下：<br>Conventional commit messages as a global utility<br>Install commitizen globally, if you have not already.</p><pre class=" language-shell"><code class="language-shell">npm install -g commitizen</code></pre><p>Install your preferred commitizen adapter globally (for example cz-conventional-changelog).</p><pre class=" language-shell"><code class="language-shell">npm install -g cz-conventional-changelog</code></pre><p>Create a .czrc file in your home directory, with path referring to the preferred, globally-installed, commitizen adapter</p><pre class=" language-shell"><code class="language-shell">echo '&#123; "path": "cz-conventional-changelog" &#125;' > ~/.czrc</code></pre><p>cd进入任何git存储库并使用git cz而不是git commit，将找到commitizen提示，根据提示用上下方向键选择即可。</p><p>翻译下来就是在 Home 目录新建一个 .czrc 文件，并且内容为</p><p>{<br>    “path”: “cz-conventional-changelog”<br>}<br>官方只给出了 Linux 的配置目录，在 ~/下面，Windows 下在 C:\Users\用户名称 下面。</p><p>然后就可以打开命令行输入git cz指令全局使用了！</p><p>这个时候我们提交代码需要使用 <code>git cz</code>：</p><ul><li>第一步是选择type，本次更新的类型</li></ul><table><thead><tr><th>Type</th><th>作用</th></tr></thead><tbody><tr><td>feat</td><td>新增特性 (feature)</td></tr><tr><td>fix</td><td>修复 Bug(bug fix)</td></tr><tr><td>docs</td><td>修改文档 (documentation)</td></tr><tr><td>style</td><td>代码格式修改(white-space, formatting, missing semi colons, etc)</td></tr><tr><td>refactor</td><td>代码重构(refactor)</td></tr><tr><td>perf</td><td>改善性能(A code change that improves performance)</td></tr><tr><td>test</td><td>测试(when adding missing tests)</td></tr><tr><td>build</td><td>变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td>ci</td><td>更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td>chore</td><td>变更构建流程或辅助工具(比如更改测试环境)</td></tr><tr><td>revert</td><td>代码回退</td></tr></tbody></table><ul><li>第二步选择本次修改的范围（作用域）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg" alt="image-20210723150147510"></p><ul><li>第三步选择提交的信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg" alt="image-20210723150204780"></p><ul><li>第四步提交详细的描述信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg" alt="image-20210723150223287"></p><ul><li>第五步是否是一次重大的更改</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg" alt="image-20210723150322122"></p><ul><li>第六步是否影响某个open issue</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg" alt="image-20210723150407822"></p><h4 id="局部配置Commitizen"><a href="#局部配置Commitizen" class="headerlink" title="局部配置Commitizen"></a>局部配置Commitizen</h4><p>1.安装Commitizen</p><pre class=" language-shell"><code class="language-shell">npm install commitizen -D</code></pre><p>2.安装cz-conventional-changelog，并且初始化cz-conventional-changelog：</p><pre class=" language-shell"><code class="language-shell">npx commitizen init cz-conventional-changelog --save-dev --save-exact</code></pre><p>这个命令会帮助我们安装cz-conventional-changelog：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvz2odi4j30ek00zmx2.jpg" alt="image-20210723145249096"></p><p>并且在package.json中进行配置：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqvzftay5j30iu04k74d.jpg"></p><p>这个时候我们提交代码需要使用 <code>npx cz</code>：</p><ul><li>第一步是选择type，本次更新的类型</li></ul><table><thead><tr><th>Type</th><th>作用</th></tr></thead><tbody><tr><td>feat</td><td>新增特性 (feature)</td></tr><tr><td>fix</td><td>修复 Bug(bug fix)</td></tr><tr><td>docs</td><td>修改文档 (documentation)</td></tr><tr><td>style</td><td>代码格式修改(white-space, formatting, missing semi colons, etc)</td></tr><tr><td>refactor</td><td>代码重构(refactor)</td></tr><tr><td>perf</td><td>改善性能(A code change that improves performance)</td></tr><tr><td>test</td><td>测试(when adding missing tests)</td></tr><tr><td>build</td><td>变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）</td></tr><tr><td>ci</td><td>更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis, Circle 等</td></tr><tr><td>chore</td><td>变更构建流程或辅助工具(比如更改测试环境)</td></tr><tr><td>revert</td><td>代码回退</td></tr></tbody></table><ul><li>第二步选择本次修改的范围（作用域）</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8ca15oj30r600wmx4.jpg" alt="image-20210723150147510"></p><ul><li>第三步选择提交的信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8mq3zlj60ni01hmx402.jpg" alt="image-20210723150204780"></p><ul><li>第四步提交详细的描述信息</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw8y05bjj30kt01fjrb.jpg" alt="image-20210723150223287"></p><ul><li>第五步是否是一次重大的更改</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqw9z5vbij30bm00q744.jpg" alt="image-20210723150322122"></p><ul><li>第六步是否影响某个open issue</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwar8xp1j30fq00ya9x.jpg" alt="image-20210723150407822"></p><p>我们也可以在scripts中构建一个命令来执行 cz：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsqwc4gtkxj30e207174t.jpg" alt="image-20210723150526211"></p>]]></content>
      
      
      <categories>
          
          <category> Angular规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> Angular </tag>
            
            <tag> Angular规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue模板语法</title>
      <link href="/2021/11/26/vue-mo-ban-yu-fa/"/>
      <url>/2021/11/26/vue-mo-ban-yu-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Vue3基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue3 </tag>
            
            <tag> Vue框架 </tag>
            
            <tag> Vue3基础 </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> Vue模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遨游前端之this</title>
      <link href="/2021/11/13/ao-you-qian-duan-zhi-this/"/>
      <url>/2021/11/13/ao-you-qian-duan-zhi-this/</url>
      
        <content type="html"><![CDATA[<blockquote><p>this是JavaScript中的一个关键字，但是又一个相对比较特别的关键字，不像function、var、for、if这些关键字一样，可以很清楚的搞清楚它到底是如何使用的。</p><p>this会在执行上下文中绑定一个对象，但是是根据什么条件绑定的呢？在不同的执行条件下会绑定不同的对象，这也是让人捉摸不定的地方。</p><p>这一次，我们一起来彻底搞定this到底是如何绑定的吧！       </p></blockquote><h2 id="一-理解this"><a href="#一-理解this" class="headerlink" title="一. 理解this"></a>一. 理解this</h2><h3 id="1-1-为什么使用this"><a href="#1-1-为什么使用this" class="headerlink" title="1.1. 为什么使用this"></a>1.1. 为什么使用this</h3><p>在常见的编程语言中，几乎都有this这个关键字（Objective-C中使用的是self），但是JavaScript中的this和常见的面向对象语言中的this不太一样：</p><ul><li>常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在<code>类的方法</code>中。</li><li>也就是你需要有一个类，类中的方法（特别是实例方法）中，this代表的是当前调用对象。</li><li>但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义。</li></ul><p>使用this有什么意义呢？下面的代码中，我们通过对象字面量创建出来一个对象，当我们调用对象的方法时，希望将对象的名称一起进行打印。</p><p>如果没有this，那么我们的代码会是下面的写法：</p><ul><li>在方法中，为了能够获取到name名称，必须通过obj的引用（变量名称）来获取。</li><li>但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info。</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token punctuation">,</span>  running<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  eating<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" eating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  studying<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" studying"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>事实上，上面的代码，在实际开发中，我们都会使用this来进行优化：</p><ul><li>当我们通过obj去调用running、eating、studying这些方法时，this就是指向的obj对象</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token punctuation">,</span>  running<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" running"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  eating<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" eating"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  studying<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">" studying"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>所以我们会发现，在某些函数或者方法的编写中，this可以让我们更加便捷的方式来引用对象，在进行一些API设计时，代码更加的简洁和易于复用。</p><p>当然，上面只是应用this的一个场景而已，开发中使用到this的场景到处都是，这也是为什么它不容易理解的原因。</p><h3 id="1-2-this指向什么"><a href="#1-2-this指向什么" class="headerlink" title="1.2. this指向什么"></a>1.2. this指向什么</h3><p>我们先说一个最简单的，this在全局作用域下指向什么？</p><ul><li>这个问题非常容易回答，在浏览器中测试就是指向window</li><li>所以，在全局作用域下，我们可以认为this就是指向的window</li></ul><pre class=" language-javascript"><code class="language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"why"</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// why</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// why</span></code></pre><p>但是，开发中很少直接在全局作用域下去使用this，通常都是在<strong>函数中使用</strong>。</p><p>所有的函数在被调用时，都会创建一个执行上下文：</p><ul><li>这个上下文中记录着函数的调用栈、函数的调用方式、传入的参数信息等；</li><li>this也是其中的一个属性；</li></ul><p>我们先来看一个让人困惑的问题：</p><ul><li>定义一个函数，我们采用三种不同的方式对它进行调用，它产生了三种不同的结果</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 定义一个函数</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 1.调用方式一: 直接调用</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// 2.调用方式二: 将foo放到一个对象中,再调用</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token comment" spellcheck="true">// 3.调用方式三: 通过call/apply调用</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// String &amp;#123;"abc"&amp;#125;对象</span></code></pre><p>上面的案例可以给我们什么样的启示呢？</p><ul><li>1.函数在调用时，JavaScript会默认给this绑定一个值；</li><li>2.this的绑定和定义的位置（编写的位置）没有关系；</li><li>3.this的绑定和调用方式以及调用的位置有关系；</li><li>4.this是在运行时被绑定的；</li></ul><p>那么this到底是怎么样的绑定规则呢？一起来学习一下吧</p><h2 id="二-this绑定规则"><a href="#二-this绑定规则" class="headerlink" title="二. this绑定规则"></a>二. this绑定规则</h2><blockquote><p>我们现在已经知道this无非就是在函数调用时被绑定的一个对象，我们就需要知道它在不同的场景下的绑定规则即可。</p></blockquote><h3 id="2-1-默认绑定"><a href="#2-1-默认绑定" class="headerlink" title="2.1. 默认绑定"></a>2.1. 默认绑定</h3><p>什么情况下使用默认绑定呢？独立函数调用。</p><ul><li>独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用；</li></ul><p><strong>案例一：普通函数调用</strong></p><ul><li>该函数直接被调用，并没有进行任何的对象关联；</li><li>这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的this指向全局对象（window）；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>案例二：函数调用链（一个函数又调用另外一个函数）</strong></p><ul><li>所有的函数调用都没有被绑定到某个对象上；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 2.案例二:</span><span class="token keyword">function</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>  <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>  <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>案例三：将函数作为参数，传入到另一个函数中</strong></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们对案例进行一些修改，考虑一下打印结果是否会发生变化：</p><ul><li>这里的结果依然是window，为什么呢？</li><li>原因非常简单，在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token punctuation">,</span>  bar<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">foo</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-2-隐式绑定"><a href="#2-2-隐式绑定" class="headerlink" title="2.2. 隐式绑定"></a>2.2. 隐式绑定</h3><p>另外一种比较常见的调用方式是通过某个对象进行调用的：</p><ul><li>也就是它的调用位置中，是通过某个对象发起的函数调用。</li></ul><p><strong>案例一：通过对象调用函数</strong></p><ul><li>foo的调用位置是obj.foo()方式进行调用的</li><li>那么foo调用时this会隐式的被绑定到obj对象上</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>案例二：案例一的变化</strong></p><ul><li>我们通过obj2又引用了obj1对象，再通过obj1对象调用foo函数；</li><li>那么foo调用的位置上其实还是obj1被绑定了this；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj1"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj2"</span><span class="token punctuation">,</span>  obj1<span class="token punctuation">:</span> obj1<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>案例三：隐式丢失</strong></p><ul><li>结果最终是window，为什么是window呢？</li><li>因为foo最终被调用的位置是bar，而bar在进行调用时没有绑定任何的对象，也就没有形成隐式绑定；</li><li>相当于是一种默认绑定；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj1"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 讲obj1的foo赋值给bar</span><span class="token keyword">var</span> bar <span class="token operator">=</span> obj1<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-3-显示绑定"><a href="#2-3-显示绑定" class="headerlink" title="2.3. 显示绑定"></a>2.3. 显示绑定</h3><p>隐式绑定有一个前提条件：</p><ul><li>必须在调用的<code>对象内部</code>有一个对函数的引用（比如一个属性）；</li><li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误；</li><li>正是通过这个引用，间接的将this绑定到了这个对象上；</li></ul><p>如果我们不希望在 <strong>对象内部</strong> 包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p><ul><li><p>JavaScript所有的函数都可以使用call和apply方法（这个和Prototype有关）。</p></li><li><ul><li>它们两个的区别这里不再展开；</li><li>其实非常简单，第一个参数是相同的，后面的参数，apply为数组，call为参数列表；</li></ul></li><li><p>这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的。</p></li><li><p>在调用这个函数时，会将this绑定到这个传入的对象上。</p></li></ul><p>因为上面的过程，我们明确的绑定了this指向的对象，所以称之为 <strong>显示绑定</strong>。</p><h4 id="2-3-1-call、apply"><a href="#2-3-1-call、apply" class="headerlink" title="2.3.1. call、apply"></a>2.3.1. call、apply</h4><p><strong>通过call或者apply绑定this对象</strong></p><ul><li>显示绑定后，this就会明确的指向绑定的对象</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// &amp;#123;name: "why"&amp;#125;</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Number对象,存放时123</span></code></pre><h4 id="2-3-2-bind函数"><a href="#2-3-2-bind函数" class="headerlink" title="2.3.2. bind函数"></a>2.3.2. bind函数</h4><p><strong>如果我们希望一个函数总是显示的绑定到一个对象上，可以怎么做呢？</strong></p><p>方案一：自己手写一个辅助函数（了解）</p><ul><li>我们手动写了一个bind的辅助函数</li><li>这个辅助函数的目的是在执行foo时，总是让它的this绑定到obj对象上</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">bind</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> func<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> <span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span></code></pre><p>方案二：使用Function.prototype.bind</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span></code></pre><h4 id="2-3-3-内置函数"><a href="#2-3-3-内置函数" class="headerlink" title="2.3.3. 内置函数"></a>2.3.3. 内置函数</h4><p>有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数。</p><ul><li>这些内置函数会要求我们传入另外一个函数；</li><li>我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行；</li><li>这些函数中的this又是如何绑定的呢？</li></ul><p><strong>案例一：setTimeout</strong></p><ul><li>setTimeout中会传入一个函数，这个函数中的this通常是window</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>为什么这里是window呢？</p><ul><li>这个和setTimeout源码的内部调用有关；</li><li>setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象；</li></ul><p><strong>案例二：数组的forEach</strong></p><p>数组有一个高阶函数forEach，用于函数的遍历：</p><ul><li>在forEach中传入的函数打印的也是Window对象；</li><li>这是因为默认情况下传入的函数是自动调用函数（默认绑定）；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"nba"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 三次window</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>我们是否可以改变该函数的this指向呢？</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"nba"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 三次obj对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>案例三：div的点击</strong></p><p>如果我们有一个div元素：</p><ul><li>注意：省略了部分代码</li></ul><pre class=" language-javascript"><code class="language-javascript">  <span class="token operator">&lt;</span>style<span class="token operator">></span>    <span class="token punctuation">.</span>box <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      width<span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>      height<span class="token punctuation">:</span> 200px<span class="token punctuation">;</span>      background<span class="token operator">-</span>color<span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>style<span class="token operator">></span>  <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"box"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>获取元素节点，并且监听点击：</p><ul><li>在点击事件的回调中，this指向谁呢？box对象；</li><li>这是因为在发生点击时，执行传入的回调函数被调用时，会将box对象绑定到该函数中；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> box <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">".box"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>box<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// box对象</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>所以传入到内置函数的回调函数this如何确定呢？</p><ul><li>某些内置的函数，我们很难确定它内部是如何调用传入的回调函数；</li><li>一方面可以通过分析源码来确定，另一方面我们可以通过经验（见多识广）来确定；</li><li>但是无论如何，通常都是我们之前讲过的规则来确定的；</li></ul><h3 id="2-4-new绑定"><a href="#2-4-new绑定" class="headerlink" title="2.4. new绑定"></a>2.4. new绑定</h3><p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字。</p><p>使用new关键字来调用函数时，会执行如下的操作：</p><ul><li>1.创建一个全新的对象；</li><li>2.这个新对象会被执行Prototype连接；</li><li>3.这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li><li>4.如果函数没有返回其他对象，表达式会返回这个新对象；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 创建Person</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Person &amp;#123;&amp;#125;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Person &amp;#123;name: "why"&amp;#125;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"why"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="2-5-规则优先级"><a href="#2-5-规则优先级" class="headerlink" title="2.5. 规则优先级"></a>2.5. 规则优先级</h3><p>学习了四条规则，接下来开发中我们只需要去查找函数的调用应用了哪条规则即可，但是如果一个函数调用位置应用了多条规则，优先级谁更高呢？</p><p><strong>1.默认规则的优先级最低</strong></p><p>毫无疑问，默认规则的优先级是最低的，因为存在其他规则时，就会通过其他规则的方式来绑定this</p><p><strong>2.显示绑定优先级高于隐式绑定</strong></p><p>显示绑定和隐式绑定哪一个优先级更高呢？这个我们可以测试一下：</p><ul><li>结果是obj2，说明是显示绑定生效了</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj1"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj2"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 隐式绑定</span>obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj1</span>obj2<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj2</span><span class="token comment" spellcheck="true">// 隐式绑定和显示绑定同时存在</span>obj1<span class="token punctuation">.</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj2, 说明显式绑定优先级更高</span></code></pre><p><strong>3.new绑定优先级高于隐式绑定</strong></p><ul><li>结果是foo，说明是new绑定生效了</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// foo对象, 说明new绑定优先级更高</span></code></pre><p><strong>4.new绑定优先级高于bind</strong></p><p>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo<span class="token punctuation">.</span>call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>new和call同时使用</p><p>但是new绑定是否可以和bind后的函数同时使用呢？可以</p><ul><li>结果显示为foo，那么说明是new绑定生效了</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// var foo = new foo.call(obj);</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印foo, 说明使用的是new绑定</span></code></pre><p>优先级总结：</p><ul><li>new绑定 &gt; 显示绑定（bind）&gt; 隐式绑定 &gt; 默认绑定</li></ul><h2 id="三-this规则之外"><a href="#三-this规则之外" class="headerlink" title="三. this规则之外"></a>三. this规则之外</h2><blockquote><p>我们讲到的规则已经足以应付平时的开发，但是总有一些语法，超出了我们的规则之外。（神话故事和动漫中总是有类似这样的人物）</p></blockquote><h3 id="3-1-忽略显示绑定"><a href="#3-1-忽略显示绑定" class="headerlink" title="3.1. 忽略显示绑定"></a>3.1. 忽略显示绑定</h3><p>如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"why"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj对象</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token keyword">var</span> bar <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span></code></pre><h3 id="3-2-间接函数引用"><a href="#3-2-间接函数引用" class="headerlink" title="3.2. 间接函数引用"></a>3.2. 间接函数引用</h3><p>另外一种情况，创建一个函数的 <code>间接引用</code>，这种情况使用默认绑定规则。</p><p>我们先来看下面的案例结果是什么？</p><ul><li>(num2 = num1)的结果是num1的值；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span><span class="token keyword">var</span> num2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">(</span>num2 <span class="token operator">=</span> num1<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 100</span></code></pre><p>我们来下面的函数赋值结果：</p><ul><li>赋值(obj2.foo = obj1.foo)的结果是foo函数；</li><li>foo函数被直接调用，那么是默认绑定；</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj1"</span><span class="token punctuation">,</span>  foo<span class="token punctuation">:</span> foo<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"obj2"</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// obj1对象</span><span class="token punctuation">(</span>obj2<span class="token punctuation">.</span>foo <span class="token operator">=</span> obj1<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// window</span></code></pre><h3 id="3-3-ES6箭头函数"><a href="#3-3-ES6箭头函数" class="headerlink" title="3.3. ES6箭头函数"></a>3.3. ES6箭头函数</h3><p>在ES6中新增一个非常好用的函数类型：箭头函数</p><ul><li>这里不再具体介绍箭头函数的用法，可以自行学习。</li></ul><p>箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。</p><p>我们来看一个模拟网络请求的案例：</p><ul><li>这里我使用setTimeout来模拟网络请求，请求到数据后如何可以存放到data中呢？</li><li>我们需要拿到obj对象，设置data；</li><li>但是直接拿到的this是window，我们需要在外层定义：<code>var _this = this</code></li><li>在setTimeout的回调函数中使用_this就代表了obj对象</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  getData<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 模拟获取到的数据</span>      <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"nba"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      _this<span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面的代码在ES6之前是我们最常用的方式，从ES6开始，我们会使用箭头函数：</p><ul><li>为什么在setTimeout的回调函数中可以直接使用this呢？</li><li>因为箭头函数并不绑定this对象，那么this引用就会从上层作用域中找到对应的this</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  getData<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 模拟获取到的数据</span>      <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"nba"</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>思考：如果getData也是一个箭头函数，那么setTimeout中的回调函数中的this指向谁呢？</p><ul><li>答案是window；</li><li>依然是不断的从上层作用域找，那么找到了全局作用域；</li><li>在全局作用域内，this代表的就是window</li></ul><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  getData<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="四-this面试题"><a href="#四-this面试题" class="headerlink" title="四. this面试题"></a>四. this面试题</h2><h3 id="4-1-面试题一："><a href="#4-1-面试题一：" class="headerlink" title="4.1. 面试题一："></a>4.1. 面试题一：</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">"window"</span><span class="token punctuation">;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">"person"</span><span class="token punctuation">,</span>  sayName<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> sss <span class="token operator">=</span> person<span class="token punctuation">.</span>sayName<span class="token punctuation">;</span>  <span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">(</span>person<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">(</span>b <span class="token operator">=</span> person<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这道面试题非常简单，无非就是绕一下，希望把面试者绕晕：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> sss <span class="token operator">=</span> person<span class="token punctuation">.</span>sayName<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 独立函数调用，没有和任何对象关联</span>  <span class="token function">sss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span>  <span class="token comment" spellcheck="true">// 关联</span>  person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// person</span>  <span class="token punctuation">(</span>person<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// person</span>  <span class="token punctuation">(</span>b <span class="token operator">=</span> person<span class="token punctuation">.</span>sayName<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// window</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h3 id="4-2-面试题二："><a href="#4-2-面试题二：" class="headerlink" title="4.2. 面试题二："></a>4.2. 面试题二：</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'window'</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  name<span class="token punctuation">:</span> <span class="token string">'person1'</span><span class="token punctuation">,</span>  foo1<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  foo2<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>  foo3<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  foo4<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span> name<span class="token punctuation">:</span> <span class="token string">'person2'</span> <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> person1<span class="token punctuation">.</span>foo1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span> person1<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>foo2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>foo3<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span>foo4<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面是代码解析：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 隐式绑定，肯定是person1</span>person1<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// person1</span><span class="token comment" spellcheck="true">// 隐式绑定和显示绑定的结合，显示绑定生效，所以是person2</span>person1<span class="token punctuation">.</span>foo1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo2()是一个箭头函数，不适用所有的规则</span>person1<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// foo2依然是箭头函数，不适用于显示绑定的规则</span>person1<span class="token punctuation">.</span>foo2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// 获取到foo3，但是调用位置是全局作用于下，所以是默认绑定window</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// foo3显示绑定到person2中</span><span class="token comment" spellcheck="true">// 但是拿到的返回函数依然是在全局下调用，所以依然是window</span>person1<span class="token punctuation">.</span>foo3<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// 拿到foo3返回的函数，通过显示绑定到person2中，所以是person2</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo4()的函数返回的是一个箭头函数</span><span class="token comment" spellcheck="true">// 箭头函数的执行找上层作用域，是person1</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person1</span><span class="token comment" spellcheck="true">// foo4()显示绑定到person2中，并且返回一个箭头函数</span><span class="token comment" spellcheck="true">// 箭头函数找上层作用域，是person2</span>person1<span class="token punctuation">.</span>foo4<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo4返回的是箭头函数，箭头函数只看上层作用域</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person1</span></code></pre><h3 id="4-3-面试题三"><a href="#4-3-面试题三" class="headerlink" title="4.3. 面试题三:"></a>4.3. 面试题三:</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'window'</span><span class="token keyword">function</span> Person <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">this</span><span class="token punctuation">.</span>foo1 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>foo2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>foo3 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>foo4 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'person1'</span><span class="token punctuation">)</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'person2'</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>foo1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span>person1<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>foo2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>foo3<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>foo4<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span></code></pre><p>下面是代码解析：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// 隐式绑定</span>person1<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// peron1</span><span class="token comment" spellcheck="true">// 显示绑定优先级大于隐式绑定</span>person1<span class="token punctuation">.</span>foo1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo是一个箭头函数，会找上层作用域中的this，那么就是person1</span>person1<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person1</span><span class="token comment" spellcheck="true">// foo是一个箭头函数，使用call调用不会影响this的绑定，和上面一样向上层查找</span>person1<span class="token punctuation">.</span>foo2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person1</span><span class="token comment" spellcheck="true">// 调用位置是全局直接调用，所以依然是window（默认绑定）</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// 最终还是拿到了foo3返回的函数，在全局直接调用（默认绑定）</span>person1<span class="token punctuation">.</span>foo3<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// 拿到foo3返回的函数后，通过call绑定到person2中进行了调用</span>person1<span class="token punctuation">.</span><span class="token function">foo3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo4返回了箭头函数，和自身绑定没有关系，上层找到person1</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person1</span><span class="token comment" spellcheck="true">// foo4调用时绑定了person2，返回的函数是箭头函数，调用时，找到了上层绑定的person2</span>person1<span class="token punctuation">.</span>foo4<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo4调用返回的箭头函数，和call调用没有关系，找到上层的person1</span>person1<span class="token punctuation">.</span><span class="token function">foo4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person1</span></code></pre><h3 id="4-4-面试题四："><a href="#4-4-面试题四：" class="headerlink" title="4.4. 面试题四："></a>4.4. 面试题四：</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'window'</span><span class="token keyword">function</span> Person <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    name<span class="token punctuation">:</span> <span class="token string">'obj'</span><span class="token punctuation">,</span>    foo1<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    foo2<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'person1'</span><span class="token punctuation">)</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'person2'</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>foo1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>foo2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span></code></pre><p>下面是代码解析：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token comment" spellcheck="true">// obj.foo1()返回一个函数</span><span class="token comment" spellcheck="true">// 这个函数在全局作用于下直接执行（默认绑定）</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span><span class="token comment" spellcheck="true">// 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span><span class="token comment" spellcheck="true">// 这个函数在全局作用于下直接执行（默认绑定）</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>foo1<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// window</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// 拿到foo2()的返回值，是一个箭头函数</span><span class="token comment" spellcheck="true">// 箭头函数在执行时找上层作用域下的this，就是obj</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// obj</span><span class="token comment" spellcheck="true">// foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span><span class="token comment" spellcheck="true">// 箭头函数在执行时找上层作用域下的this，找到的是person2</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span>foo2<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// person2</span><span class="token comment" spellcheck="true">// foo2()的返回值，依然是箭头函数</span><span class="token comment" spellcheck="true">// 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span>person1<span class="token punctuation">.</span>obj<span class="token punctuation">.</span><span class="token function">foo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>person2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// obj</span></code></pre><p><strong>此贴转发来源：coderwhy</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端基础 </tag>
            
            <tag> 前端 </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3简介</title>
      <link href="/2021/10/25/vue3-kai-fa-xue-xi-xie-hou/"/>
      <url>/2021/10/25/vue3-kai-fa-xue-xi-xie-hou/</url>
      
        <content type="html"><![CDATA[<p>​        <strong>Vue框架在前端世界可谓是一个必学的框架，它是由尤雨溪大神，这位前端天花板编写的开源代码，现在在国内国外都被广泛使用中。接下来让我们一起开始Vue的学习吧！</strong></p><h2 id="认识Vue框架"><a href="#认识Vue框架" class="headerlink" title="认识Vue框架"></a>认识Vue框架</h2><h4 id="Vue是一套用于构建用户界面的渐进式框架。"><a href="#Vue是一套用于构建用户界面的渐进式框架。" class="headerlink" title="Vue是一套用于构建用户界面的渐进式框架。"></a>Vue是一套用于构建用户界面的渐进式框架。</h4><p>​    全称是<strong>Vue.js</strong>或者<strong>Vuejs</strong>; </p><p>​    什么是渐进式框架？用通俗的话来讲，就是我们可以在项目中一点点来引入或者使用Vue，而不一定需要全部使用Vue来开发整个项目，其核心是一个允许使用模板语法来声明式地将数据渲染进DOM的系统。</p><h4 id="目前Vue在前端处于什么地位？"><a href="#目前Vue在前端处于什么地位？" class="headerlink" title="目前Vue在前端处于什么地位？"></a>目前Vue在前端处于什么地位？</h4><p>​    目前前端最流行的三大框架有： <strong>Vue</strong>， <strong>React</strong>，<strong>Angular</strong>.</p><p>​    <img src="https://cdn.jsdelivr.net/gh/noreason123/IMG/d6ebbb7c0b4449216b67367a60e4ff5.png" alt="前端最流行的三大框架" title="前端最流行的三大框架"></p><p>​    <strong>学好Vue至关重要。</strong></p><pre><code>####     尤雨溪：直接学 Vue3 就行了，基础概念是一模一样的。</code></pre><p>​    Vue3新特性：<strong>更好的性能，更小的包体积，更好的TypeScript集成，更优秀的API设计。</strong></p><p>​    Vue3带来的变化：源码通过monorepo的形式来管理源代码，使用TypeScript进行重写；使用Proxy进行数据劫持，删除了一些不必要的API，由Options API到Composition API，Hooks函数增加代码的复用性。概念比较抽象，但以后会系统学习到。</p><pre><code>####     如何使用Vue呢？</code></pre><p>​    Vue的本质就是一个<strong>JavaScript库</strong>。安装和使用Vue的方式有：</p><p>​    方法一：在页面中通过CDN的方式来引入；</p><p>​    方式二：下载Vue的JavaScript文件，并且自己手动引入；</p><p>​    方式三：通过npm包管理工具安装使用它；</p><p>​    方式四：直接通过Vue CLI创建项目，并且使用它；</p><pre><code>#####     CDN引入</code></pre><p>​     什么是CDN呢？CDN称之为<strong>内容分发网络</strong>，它是指通过 相互连接的网络系统，利用最靠近每个用户的服务器更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，从而来提供高性能、可扩展性及低成本的网络内容传递给用户。</p><p>​    </p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://unpkg.com/vue@next"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><pre><code>#####     下载源码引入</code></pre><p>​    直接打开CDN的链接，打开链接，复制其中所有的代码。创建一个新的文件，比如vue.js，将代码复制到其中，通过script标签，引入刚才的文件：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"/vue.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><pre><code>####     原生开发和Vue开发模式的不同</code></pre><p>​    这里其实涉及到两种不同的编程范式：命令式编程和声明式编程；原生开发就是命令式编程，关注的是 “how to do”，Vue框架则为声明式编程，关注的是 “what to do”，由框架完成 “how”的过程。在早期的原生JavaScript和jQuery开发的过程中，我们都是通过这种命令式的方式在编写代码的，而目前Vue、React、Angular的编程模式，我们称之为声明式编程。</p><p>​    <strong>MVVM模型：</strong>是Model-View-ViewModel的简称，是目前非常流行的架构模式。通常情况下，我们也经常称Vue是一个MVVM的框架。Vue官方其实有说明，Vue虽然并没有完全遵守MVVM的模型，但是整个设计是受到它的启发的。</p><p>​    </p><pre><code>####     如何查看Vue的源码    </code></pre><ul><li><p>在GitHub上搜索 vue-next，下载源代码，推荐通过 git clone 的方式下载</p></li><li><p>安装Vue源码项目相关的依赖，在终端中执行：</p><p><code>yarn install</code></p></li><li><p>对项目执行打包操作，修改package包下的package.json：</p><pre class=" language-json"><code class="language-json"><span class="token property">"scripts"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"dev"</span><span class="token operator">:</span> <span class="token string">"node scripts/dev.js --sourcemap"</span><span class="token punctuation">,</span></code></pre><p>在终端中执行：</p><p><code>yarn dev</code></p><p><strong>Vue的学习是一个漫长但要扎实的过程，继续加油吧！</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Vue3基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Vue3 </tag>
            
            <tag> Vue框架 </tag>
            
            <tag> Vue3基础 </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello，我的第一篇Blog</title>
      <link href="/2021/10/24/hello-world/"/>
      <url>/2021/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="大家好，我是华南农业大学软件工程在读本科生reason。终于，经过我一天的折腾，属于我自己的博客网站搭建好了，接下来让我们一起开始学习吧，一起加油。"><a href="#大家好，我是华南农业大学软件工程在读本科生reason。终于，经过我一天的折腾，属于我自己的博客网站搭建好了，接下来让我们一起开始学习吧，一起加油。" class="headerlink" title="大家好，我是华南农业大学软件工程在读本科生reason。终于，经过我一天的折腾，属于我自己的博客网站搭建好了，接下来让我们一起开始学习吧，一起加油。"></a>大家好，我是华南农业大学软件工程在读本科生reason。终于，经过我一天的折腾，属于我自己的博客网站搭建好了，接下来让我们一起开始学习吧，一起加油。</h2><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"Hello World"</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 闲聊 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 闲聊 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
